<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-03-10 Tue 10:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CMPUT201W20B2 Week 6</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Abram Hindle" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CMPUT201W20B2 Week 6</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org688eccf">1. Week6</a>
<ul>
<li><a href="#orgd748558">1.1. Copyright Statement</a>
<ul>
<li><a href="#orgec5540d">1.1.1. License</a></li>
<li><a href="#orgd548298">1.1.2. Hazel Code is licensed under AGPL3.0+</a></li>
</ul>
</li>
<li><a href="#org7e15755">1.2. Init ORG-MODE</a>
<ul>
<li><a href="#org1dd4d51">1.2.1. Org export</a></li>
</ul>
</li>
<li><a href="#org26c1dff">1.3. Org Template</a></li>
<li><a href="#org0ff7ad7">1.4. Remember how to compile?</a></li>
<li><a href="#orgd8b50a7">1.5. Structs!</a>
<ul>
<li><a href="#org7f19900">1.5.1. A pointer is not a l value</a></li>
<li><a href="#org73fb976">1.5.2. Struct Intro</a></li>
<li><a href="#org9635326">1.5.3. Structs in memory</a></li>
<li><a href="#org647e6e7">1.5.4. Initializing</a></li>
<li><a href="#org0952526">1.5.5. Structure Types</a></li>
<li><a href="#org62706ff">1.5.6. Pointers and Structs</a></li>
<li><a href="#org413a5e5">1.5.7. Elaborate Matrix Example</a></li>
</ul>
</li>
<li><a href="#org0903ecb">1.6. Enum</a>
<ul>
<li><a href="#orgb53bdb3">1.6.1. Enum Example</a></li>
<li><a href="#orga2355a9">1.6.2. enum<sub>typedef.c</sub></a></li>
<li><a href="#org001d19a">1.6.3. EnumStart</a></li>
<li><a href="#org86e90ee">1.6.4. Enumassign</a></li>
<li><a href="#org70bdbae">1.6.5. Enum<sub>loop</sub><sub>trick.c</sub></a></li>
<li><a href="#org6ff2edc">1.6.6. Enum Int</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org688eccf" class="outline-2">
<h2 id="org688eccf"><span class="section-number-2">1</span> Week6</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgd748558" class="outline-3">
<h3 id="orgd748558"><span class="section-number-3">1.1</span> Copyright Statement</h3>
<div class="outline-text-3" id="text-1-1">
<p>
If you are in CMPUT201 at UAlberta this code is released in the public
domain to you.
</p>

<p>
Otherwise it is (c) 2020 Abram Hindle, Hazel Campbell AGPL3.0+
</p>
</div>

<div id="outline-container-orgec5540d" class="outline-4">
<h4 id="orgec5540d"><span class="section-number-4">1.1.1</span> License</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Week 3 notes
Copyright (C) 2020 Abram Hindle, Hazel Campbell
</p>

<p>
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.
</p>

<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.
</p>

<p>
You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
</p>
</div>
</div>


<div id="outline-container-orgd548298" class="outline-4">
<h4 id="orgd548298"><span class="section-number-4">1.1.2</span> Hazel Code is licensed under AGPL3.0+</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Hazel's code is also found here
<a href="https://github.com/hazelybell/examples/tree/C-2020-01">https://github.com/hazelybell/examples/tree/C-2020-01</a>
</p>

<p>
Hazel code is licensed: The example code is licensed under the AGPL3+
license, unless otherwise noted.
</p>
</div>
</div>
</div>

<div id="outline-container-org7e15755" class="outline-3">
<h3 id="org7e15755"><span class="section-number-3">1.2</span> Init ORG-MODE</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">I need this for org-mode to work well</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">If we have a new org-mode use ob-shell</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">otherwise use ob-sh --- but not both!</span>
(<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">ob-shell</span> nil 'noerror)
  (<span style="color: #a020f0;">progn</span>
    (org-babel-do-load-languages 'org-babel-load-languages '((shell . t))))
  (<span style="color: #a020f0;">progn</span>
    (<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">ob-sh</span>)
    (org-babel-do-load-languages 'org-babel-load-languages '((sh . t)))))
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
(<span style="color: #a020f0;">setq</span> org-src-fontify-natively t)
(<span style="color: #a020f0;">setq</span> org-confirm-babel-evaluate nil) <span style="color: #b22222;">;; </span><span style="color: #b22222;">danger!</span>
(custom-set-faces
 '(org-block ((t (<span style="color: #483d8b;">:inherit</span> shadow <span style="color: #483d8b;">:foreground</span> <span style="color: #8b2252;">"black"</span>)))))
</pre>
</div>
</div>

<div id="outline-container-org1dd4d51" class="outline-4">
<h4 id="org1dd4d51"><span class="section-number-4">1.2.1</span> Org export</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-elisp">(org-html-export-to-html)
(org-latex-export-to-pdf)
(org-ascii-export-to-ascii)
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org26c1dff" class="outline-3">
<h3 id="org26c1dff"><span class="section-number-3">1.3</span> Org Template</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Copy and paste this to demo C
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span>**<span style="color: #a0522d;">argv</span>) {
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ff7ad7" class="outline-3">
<h3 id="org0ff7ad7"><span class="section-number-3">1.4</span> Remember how to compile?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
gcc -std=c99 -Wall -pedantic -Werror -o programname programname.c
</p>
</div>
</div>

<div id="outline-container-orgd8b50a7" class="outline-3">
<h3 id="orgd8b50a7"><span class="section-number-3">1.5</span> Structs!</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org7f19900" class="outline-4">
<h4 id="org7f19900"><span class="section-number-4">1.5.1</span> A pointer is not a l value</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
p = string
p++
tmp = p
p = (char*)p + 1*sizeof(void)
</p>
</div>
</div>


<div id="outline-container-org73fb976" class="outline-4">
<h4 id="org73fb976"><span class="section-number-4">1.5.2</span> Struct Intro</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
How do you store a record?
</p>

<p>
In python you typically use a dictionary and store key value pairs
within a dictionary.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a0522d;">my_pet</span> = {<span style="color: #8b2252;">"name"</span>:<span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"type"</span>:<span style="color: #8b2252;">"dog"</span>, <span style="color: #8b2252;">"age"</span>:6 }
</pre>
</div>

<p>
In C structures allow you to group relevant information together such
that you can access fields (properties).
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NAME_LEN</span> 17
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TYPE_LEN</span> 9
<span style="color: #a020f0;">struct</span> {
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[NAME_LEN];
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">type</span>[TYPE_LEN];
    <span style="color: #228b22;">int</span>  <span style="color: #a0522d;">age</span>;
} <span style="color: #a0522d;">my_pet</span>;
</pre>
</div>

<p>
In python you access the dictionary or object with:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a0522d;">my_pet</span> = {<span style="color: #8b2252;">"name"</span>:<span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"type"</span>:<span style="color: #8b2252;">"dog"</span>, <span style="color: #8b2252;">"age"</span>:6 }
my_pet[<span style="color: #8b2252;">"name"</span>]
<span style="color: #b22222;"># </span><span style="color: #b22222;">or if it was an object</span>
<span style="color: #a0522d;">my_pet</span> = Pet(<span style="color: #8b2252;">"Dan"</span>,<span style="color: #8b2252;">"dog"</span>,6)
my_pet.name
</pre>
</div>

<p>
(&amp;my<sub>pet</sub>)-&gt;name
my<sub>pet.name</sub>
</p>

<p>
In C with structs you use the dot operator to access fields or members
of the structs
</p>

<p>
names = { "Darren", "Dan" }
ages  = { 3       , 6 }
type  = {"cat",     "dog" }
          0           1
</p>

<p>
#define DARREN 0
names[DARREN]
ages[DARREN]
type[DARREN]
</p>

<p>
darren.name
darren.age
darren.type
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NAME_LEN</span> 17
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TYPE_LEN</span> 9

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">struct</span> { 
        <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>;
        <span style="color: #228b22;">int</span> <span style="color: #a0522d;">y</span>;
    } <span style="color: #a0522d;">foo</span>;
    <span style="color: #a020f0;">struct</span> { <span style="color: #b22222;">// </span><span style="color: #b22222;">declare a struct type</span>
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[NAME_LEN];
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">type</span>[TYPE_LEN];
        <span style="color: #228b22;">double</span> <span style="color: #a0522d;">doub</span>;
        <span style="color: #228b22;">int</span>  <span style="color: #a0522d;">age</span>;
   } <span style="color: #a0522d;">my_pet</span>  = { <span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"dog"</span>, 5.0, 6 }, <span style="color: #b22222;">// </span><span style="color: #b22222;">name and initialize 1 instance of the struct</span>
     <span style="color: #a0522d;">my_pet2</span> = { <span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"dog"</span>, 5.0, 6 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">name and initialize 1 instance of the struct</span>
   printf(<span style="color: #8b2252;">"%s, %s, %d\n"</span>, my_pet.name, my_pet.type, my_pet.age);
   printf(<span style="color: #8b2252;">"sizeof(my_pet)=%lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(my_pet));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9635326" class="outline-4">
<h4 id="org9635326"><span class="section-number-4">1.5.3</span> Structs in memory</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
Structs are very compact. They are all their field datatypes stacked
together.
</p>

<p>
It will be mixed datatypes in memory:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">name</th>
<th scope="col" class="org-right">offset</th>
<th scope="col" class="org-left">value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">name</td>
<td class="org-right">0</td>
<td class="org-left">"Dan\0"</td>
</tr>

<tr>
<td class="org-left">type</td>
<td class="org-right">17</td>
<td class="org-left">"dog\0"</td>
</tr>

<tr>
<td class="org-left">age</td>
<td class="org-right">26</td>
<td class="org-left">6</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">8</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">12</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">16</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">20</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">24</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">26</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">'D'</td>
<td class="org-left">'a'</td>
<td class="org-left">'n'</td>
<td class="org-left">'\0'</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">'d'</td>
<td class="org-left">'o'</td>
<td class="org-left">'g'</td>
<td class="org-right">'\0'</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">00</td>
<td class="org-right">00</td>
<td class="org-right">00</td>
<td class="org-right">06</td>
</tr>
</tbody>
</table>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NAME_LEN</span> 17
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TYPE_LEN</span> 9

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">struct</span> { <span style="color: #b22222;">// </span><span style="color: #b22222;">declare a struct type</span>
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[NAME_LEN];
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">type</span>[TYPE_LEN];
        <span style="color: #228b22;">int</span>  <span style="color: #a0522d;">age</span>;
   } <span style="color: #a0522d;">my_pet</span> = { <span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"dog"</span>, 6 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">name and initialize 1 instance of the struct</span>
   printf(<span style="color: #8b2252;">"%s, %s, %d\n"</span>, my_pet.name, my_pet.type, my_pet.age);
   printf(<span style="color: #8b2252;">"struct      location:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;my_pet);
   printf(<span style="color: #8b2252;">"my_pet.name location:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;my_pet.name);
   printf(<span style="color: #8b2252;">"my_pet.type location:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;my_pet.type);
   printf(<span style="color: #8b2252;">"my_pet.age  location:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;my_pet.age);
   printf(<span style="color: #8b2252;">"my_pet.name size:\t %lu\n"</span>, <span style="color: #a020f0;">sizeof</span>(my_pet.name));
   printf(<span style="color: #8b2252;">"my_pet.type size:\t %lu\n"</span>, <span style="color: #a020f0;">sizeof</span>(my_pet.type));
   printf(<span style="color: #8b2252;">"my_pet.age  size:\t %lu\n"</span>, <span style="color: #a020f0;">sizeof</span>(my_pet.age));
   printf(<span style="color: #8b2252;">"sizeof(my_pet)=%lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(my_pet));

}
</pre>
</div>

<pre class="example">
Dan, dog, 6
struct      location:	 0x7ffddab4ee70
my_pet.name location:	 0x7ffddab4ee70
my_pet.type location:	 0x7ffddab4ee81
my_pet.age  location:	 0x7ffddab4ee8c
my_pet.name size:	 17
my_pet.type size:	 9
my_pet.age  size:	 4
sizeof(my_pet)=32

</pre>
</div>
</div>

<div id="outline-container-org647e6e7" class="outline-4">
<h4 id="org647e6e7"><span class="section-number-4">1.5.4</span> Initializing</h4>
<div class="outline-text-4" id="text-1-5-4">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NAME_LEN</span> 17
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TYPE_LEN</span> 9

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">struct</span> { <span style="color: #b22222;">// </span><span style="color: #b22222;">declare a struct type</span>
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[NAME_LEN];
        <span style="color: #228b22;">char</span> <span style="color: #a0522d;">type</span>[TYPE_LEN];
        <span style="color: #228b22;">int</span>  <span style="color: #a0522d;">age</span>;
   } <span style="color: #a0522d;">my_pet1</span> = { <span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"dog"</span>, 6 }, <span style="color: #b22222;">// </span><span style="color: #b22222;">name and initialize 1 instance of the struct</span>
     <span style="color: #a0522d;">my_pet2</span> = { .name = <span style="color: #8b2252;">"Darren"</span>, .type = <span style="color: #8b2252;">"cat"</span>, .age = 3 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">designated initializer</span>
   printf(<span style="color: #8b2252;">"%s and %s get along just fine.\n"</span>, my_pet1.name, my_pet2.name);
}
</pre>
</div>

<pre class="example">
Dan and Darren get along just fine.

</pre>
</div>
</div>


<div id="outline-container-org0952526" class="outline-4">
<h4 id="org0952526"><span class="section-number-4">1.5.5</span> Structure Types</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
You can predeclare structure "tags" ahead of time so you can reuse your type.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NAME_LEN</span> 17
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TYPE_LEN</span> 9

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">my_pet</span> { <span style="color: #b22222;">// </span><span style="color: #b22222;">declare a struct type</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[NAME_LEN];
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">type</span>[TYPE_LEN];
    <span style="color: #228b22;">int</span>  <span style="color: #a0522d;">age</span>;
}; <span style="color: #b22222;">// </span><span style="color: #b22222;">REMEMBER THE SEMICOLON</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">my_pet</span> <span style="color: #a0522d;">my_pet1</span> = { <span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"dog"</span>, 6 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">name and initialize 1 instance of the struct</span>
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">my_pet</span> <span style="color: #a0522d;">my_pet2</span> = { .name = <span style="color: #8b2252;">"Darren"</span>, .type = <span style="color: #8b2252;">"cat"</span>, .age = 3 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">designated initializer</span>
    printf(<span style="color: #8b2252;">"%s and %s get along just fine.\n"</span>, my_pet1.name, my_pet2.name);
}
</pre>
</div>

<pre class="example">
Dan and Darren get along just fine.

</pre>
</div>

<ol class="org-ol">
<li><a id="org278bad5"></a>Typedef instead of struct tag<br />
<div class="outline-text-5" id="text-1-5-5-1">
<p>
You can also typedef it away but it causes issues later.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NAME_LEN</span> 17
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TYPE_LEN</span> 9

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> { <span style="color: #b22222;">// </span><span style="color: #b22222;">declare a struct type</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[NAME_LEN];
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">type</span>[TYPE_LEN];
    <span style="color: #228b22;">int</span>  <span style="color: #a0522d;">age</span>;
} <span style="color: #228b22;">MyPet</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">REMEMBER THE SEMICOLON</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">MyPet</span> <span style="color: #a0522d;">my_pet1</span> = { <span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"dog"</span>, 6 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">name and initialize 1 instance of the struct</span>
    <span style="color: #228b22;">MyPet</span> <span style="color: #a0522d;">my_pet2</span> = { .name = <span style="color: #8b2252;">"Darren"</span>, .type = <span style="color: #8b2252;">"cat"</span>, .age = 3 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">designated initializer</span>
    printf(<span style="color: #8b2252;">"%s and %s get along just fine.\n"</span>, my_pet1.name, my_pet2.name);
}
</pre>
</div>

<pre class="example">
Dan and Darren get along just fine.

</pre>
</div>
</li>

<li><a id="org9fca17e"></a>Or combine both typedef and struct tags<br />
<div class="outline-text-5" id="text-1-5-5-2">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NAME_LEN</span> 17
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">TYPE_LEN</span> 9

<span style="color: #b22222;">// </span><span style="color: #b22222;">First declare the struct tag</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">struct my_pet</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">my_pet</span> { <span style="color: #b22222;">// </span><span style="color: #b22222;">declare a struct type</span>
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[NAME_LEN];
    <span style="color: #228b22;">char</span> <span style="color: #a0522d;">type</span>[TYPE_LEN];
    <span style="color: #228b22;">int</span>  <span style="color: #a0522d;">age</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">my_pet</span> * <span style="color: #a0522d;">ptr</span>;
}; <span style="color: #b22222;">// </span><span style="color: #b22222;">REMEMBER THE SEMICOLON</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">Then typedef it</span>

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">my_pet</span> <span style="color: #228b22;">MyPet</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">MyPet</span> <span style="color: #a0522d;">my_pet1</span> = { <span style="color: #8b2252;">"Dan"</span>, <span style="color: #8b2252;">"dog"</span>, 6 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">name and initialize 1 instance of the struct</span>
    <span style="color: #228b22;">MyPet</span> <span style="color: #a0522d;">my_pet2</span> = { .name = <span style="color: #8b2252;">"Darren"</span>, .type = <span style="color: #8b2252;">"cat"</span>, .age = 3 }; <span style="color: #b22222;">// </span><span style="color: #b22222;">designated initializer</span>
    printf(<span style="color: #8b2252;">"%s and %s get along just fine.\n"</span>, my_pet1.name, my_pet2.name);
}
</pre>
</div>

<pre class="example">
Dan and Darren get along just fine.

</pre>
</div>
</li>

<li><a id="orga85cccf"></a>Hazel's example of typedef and style<br />
<div class="outline-text-5" id="text-1-5-5-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">A common thing to do is to typedef a struct</span>
<span style="color: #b22222;"> * so that you don't have to type struct whatever</span>
<span style="color: #b22222;"> * so often.</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> {
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">x</span>;
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">y</span>;
};

<span style="color: #b22222;">// </span><span style="color: #b22222;">We use a capital first letter to indicate a type</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">This is a newer style.</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> <span style="color: #228b22;">Coordinate</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">Or we could use "_t" at the end.</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">This is an older style. Remember uint64_t?</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> <span style="color: #228b22;">coordinate_t</span>;

<span style="color: #228b22;">Coordinate</span> <span style="color: #0000ff;">move_left</span>(<span style="color: #228b22;">Coordinate</span> <span style="color: #a0522d;">position</span>) {
    position.x -= 1.0;
    <span style="color: #a020f0;">return</span> position;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Coordinate</span> <span style="color: #a0522d;">position</span> = { 0, 0 };
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
    <span style="color: #228b22;">Coordinate</span> <span style="color: #a0522d;">new_position</span> = move_left(position);
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
    printf(<span style="color: #8b2252;">"new_position=(%g,%g)\n"</span>,
           new_position.x,
           new_position.y
    );
    position = move_left(move_left(position));
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
}
</pre>
</div>

<pre class="example">
position=(0,0)
position=(0,0)
new_position=(-1,0)
position=(-2,0)

</pre>
</div>
</li>


<li><a id="orged998ad"></a>Pass by Value Gotcha<br />
<div class="outline-text-5" id="text-1-5-5-4">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">The important thing to notice here is that</span>
<span style="color: #b22222;"> * structs are pass-by-value. Just like a single float,</span>
<span style="color: #b22222;"> * when we pass a struct to a function it gets a COPY</span>
<span style="color: #b22222;"> * of the original struct!</span>
<span style="color: #b22222;"> * We can also assign structs and we get a COPY.</span>
<span style="color: #b22222;"> * We can also return structs and we get a COPY.</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> { <span style="color: #b22222;">// </span><span style="color: #b22222;">leaving behind for size comparison</span>
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">x</span>;
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">y</span>;
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">named_coordinate</span> {
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">x</span>;
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">y</span>;
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">name</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">WARNING this is a pointer!</span>
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">named_coordinate</span> <span style="color: #0000ff;">move_left</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">named_coordinate</span> <span style="color: #a0522d;">position</span>) {
    printf(<span style="color: #8b2252;">"I am moving position.name: %s [%p] LEFT\n"</span>, 
           position.name, 
           (<span style="color: #228b22;">void</span>*)position.name);
    position.x -= 1.0;
    <span style="color: #a020f0;">return</span> position;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">my_string_literal</span> = <span style="color: #8b2252;">"YoloStringLiteral!-X-X-X-X-X-X"</span>;
    printf(<span style="color: #8b2252;">"my_string_literal pointer is at %p\n"</span>, (<span style="color: #228b22;">void</span>*)(&amp;my_string_literal));
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">named_coordinate</span> <span style="color: #a0522d;">position</span> = { 0, 0, my_string_literal };
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">named_coordinate</span> <span style="color: #a0522d;">new_position</span> = move_left(position);
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
    printf(<span style="color: #8b2252;">"new_position=(%g,%g)\n"</span>,
           new_position.x,
           new_position.y
    );
    position = move_left(move_left(position));
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
    <span style="color: #b22222;">// </span><span style="color: #b22222;">So we now have a string in our struct? How does it change the struct?</span>
    printf(<span style="color: #8b2252;">"Size of named_coordinate: %lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(new_position));
    printf(<span style="color: #8b2252;">"Size of coordinate: %lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span>));
    printf(<span style="color: #8b2252;">"Size of my_string_literal: %lu\n"</span>,<span style="color: #a020f0;">sizeof</span>(my_string_literal));
    printf(<span style="color: #8b2252;">"strlen of my_string_literal: %lu\n"</span>,strlen(my_string_literal));
    <span style="color: #b22222;">// </span><span style="color: #b22222;">COPY BY VALUE MEANS POINTERS ARE COPIED, but not their contents.</span>
    printf(<span style="color: #8b2252;">"&amp;position.name     %p\n"</span>,(<span style="color: #228b22;">void</span>*)&amp;position.name); <span style="color: #b22222;">// </span><span style="color: #b22222;">they have different pointers</span>
    printf(<span style="color: #8b2252;">"&amp;new_position.name %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;new_position.name);  <span style="color: #b22222;">// </span><span style="color: #b22222;">they have different pointers</span>
    printf(<span style="color: #8b2252;">"position.name      %p\n"</span>, (<span style="color: #228b22;">void</span>*)position.name); <span style="color: #b22222;">// </span><span style="color: #b22222;">but they point to the same thing</span>
    printf(<span style="color: #8b2252;">"new_position.name  %p\n"</span>, (<span style="color: #228b22;">void</span>*)new_position.name); <span style="color: #b22222;">// </span><span style="color: #b22222;">but they point to the same thing</span>
    printf(<span style="color: #8b2252;">"position.name      %s\n"</span>, position.name); <span style="color: #b22222;">// </span><span style="color: #b22222;">but they point to the same thing</span>
    printf(<span style="color: #8b2252;">"new_position.name  %s\n"</span>, new_position.name); <span style="color: #b22222;">// </span><span style="color: #b22222;">but they point to the same thing</span>

}
</pre>
</div>

<pre class="example">
my_string_literal pointer is at 0x7ffe79be7ce8
position=(0,0)
I am moving position.name: YoloStringLiteral!-X-X-X-X-X-X [0x55b28f376a98] LEFT
position=(0,0)
new_position=(-1,0)
I am moving position.name: YoloStringLiteral!-X-X-X-X-X-X [0x55b28f376a98] LEFT
I am moving position.name: YoloStringLiteral!-X-X-X-X-X-X [0x55b28f376a98] LEFT
position=(-2,0)
Size of named_coordinate: 16
Size of coordinate: 8
Size of my_string_literal: 8
strlen of my_string_literal: 30
&amp;position.name     0x7ffe79be7cf8
&amp;new_position.name 0x7ffe79be7d08
position.name      0x55b28f376a98
new_position.name  0x55b28f376a98
position.name      YoloStringLiteral!-X-X-X-X-X-X
new_position.name  YoloStringLiteral!-X-X-X-X-X-X
</pre>
</div>
</li>
</ol>
</div>


<div id="outline-container-org62706ff" class="outline-4">
<h4 id="org62706ff"><span class="section-number-4">1.5.6</span> Pointers and Structs</h4>
<div class="outline-text-4" id="text-1-5-6">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">Using pointers to structs is very common.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * Using typedef to define a type that is a pointer</span>
<span style="color: #b22222;"> * to a particular kind of struct is also very common</span>
<span style="color: #b22222;"> * to avoid having to write the pointer everywhere.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * This allows us to make a sort of </span>
<span style="color: #b22222;"> * object-like variable.</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> {
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">x</span>;
    <span style="color: #228b22;">float</span> <span style="color: #a0522d;">y</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> *<span style="color: #228b22;">Coordinate</span>;
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> *<span style="color: #228b22;">coordinate_t</span>;

<span style="color: #b22222;">// </span><span style="color: #b22222;">When we have a pointer to a struct, we use</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">"-&gt;" instead of "." to talk about a field.</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">move_left</span>(<span style="color: #228b22;">Coordinate</span> <span style="color: #a0522d;">position</span>) {
    position-&gt;x -= 1.0;
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">"ptr-&gt;field" is just shorthand for "(*ptr).field"</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">move_up</span>(<span style="color: #228b22;">Coordinate</span> <span style="color: #a0522d;">position</span>) {
    position-&gt;y -= 1.0;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">coordinate</span> <span style="color: #a0522d;">position</span> = { 0, 0 };
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
    move_left(&amp;position);
    move_up(&amp;position);
    printf(<span style="color: #8b2252;">"position=(%g,%g)\n"</span>,
           position.x,
           position.y
    );
}
</pre>
</div>

<pre class="example">
position=(0,0)
position=(-1,-1)

</pre>
</div>
</div>

<div id="outline-container-org413a5e5" class="outline-4">
<h4 id="org413a5e5"><span class="section-number-4">1.5.7</span> Elaborate Matrix Example</h4>
<div class="outline-text-4" id="text-1-5-7">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">But we don't just want to avoid duplicate function</span>
<span style="color: #b22222;"> * parameters, we want to avoid duplicate code too!</span>
<span style="color: #b22222;"> * Noticing that our bounds checking code appears</span>
<span style="color: #b22222;"> * twice, let's refactor...</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">matrix</span> {
    <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">elements</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">rows</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">cols</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">matrix</span> <span style="color: #228b22;">Matrix</span>;

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">matrix_element</span> {
    <span style="color: #228b22;">Matrix</span> <span style="color: #a0522d;">matrix</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">row</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">col</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">matrix_element</span> <span style="color: #228b22;">MatrixElement</span>;

<span style="color: #b22222;">/* </span><span style="color: #b22222;">We can add our own bounds-checking to C!</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">bounds_check</span>(<span style="color: #228b22;">MatrixElement</span> <span style="color: #a0522d;">elt</span>) {
    <span style="color: #a020f0;">if</span> (elt.row &gt;= elt.matrix.rows) {
        printf(<span style="color: #8b2252;">"Error: row index out of bounds!\n"</span>);
        abort();
    }
    <span style="color: #a020f0;">if</span> (elt.col &gt;= elt.matrix.cols) {
        printf(<span style="color: #8b2252;">"Error: col index out of bounds!\n"</span>);
        abort();
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get_element</span>(<span style="color: #228b22;">MatrixElement</span> <span style="color: #a0522d;">elt</span>) {
    bounds_check(elt);
    <span style="color: #a020f0;">return</span> elt.matrix.elements[
        elt.row * elt.matrix.cols + elt.col
    ];
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">set_element</span>(
    <span style="color: #228b22;">MatrixElement</span> <span style="color: #a0522d;">elt</span>,
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">value</span>
) {
    bounds_check(elt);
    elt.matrix.elements[
        elt.row * elt.matrix.cols + elt.col
    ] = value;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">init_matrix</span>(<span style="color: #228b22;">Matrix</span> <span style="color: #a0522d;">matrix</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Note we don't have to keep reallocating memory because </span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">structs are COPIED</span>
    <span style="color: #228b22;">MatrixElement</span> <span style="color: #a0522d;">elt</span> = {matrix, 0, 0};
    <span style="color: #a020f0;">for</span> (elt.row = 0; elt.row &lt; matrix.rows; elt.row++) {
        <span style="color: #a020f0;">for</span> (elt.col = 0; elt.col &lt; matrix.cols; elt.col++) {
            set_element(elt, 0);
        }
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_matrix</span>(<span style="color: #228b22;">Matrix</span> <span style="color: #a0522d;">matrix</span>) {
    <span style="color: #228b22;">MatrixElement</span> <span style="color: #a0522d;">elt</span> = {matrix, 0, 0};
    <span style="color: #a020f0;">for</span> (elt.row = 0; elt.row &lt; matrix.rows; elt.row++) {
        <span style="color: #a020f0;">for</span> (elt.col = 0; elt.col &lt; matrix.cols; elt.col++) {
            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">value</span> = get_element(elt);
            printf(<span style="color: #8b2252;">"%d "</span>, value);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">rows</span> = 3;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">cols</span> = 3;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we will use our init_matrix function to initialize insead of an</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">initializer. That way we don't have know the size of</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">matrix_memory at compile time.</span>
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">matrix_memory</span>[rows * cols];
    <span style="color: #228b22;">Matrix</span> <span style="color: #a0522d;">matrix</span> = { matrix_memory, rows, cols };
    init_matrix(matrix);
    print_matrix(matrix);
    printf(<span style="color: #8b2252;">"\n"</span>);
    <span style="color: #228b22;">MatrixElement</span> <span style="color: #a0522d;">elt</span> = {matrix, 1, 1};
    set_element(elt, 2);
    print_matrix(matrix);
}
</pre>
</div>

<pre class="example">
0 0 0 
0 0 0 
0 0 0 

0 0 0 
0 2 0 
0 0 0

</pre>
</div>
</div>
</div>

<div id="outline-container-org0903ecb" class="outline-3">
<h3 id="org0903ecb"><span class="section-number-3">1.6</span> Enum</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Enums are enumerations, which is just a convienant way to make symbols
that have different values of the same type. Enums allow us to read
and write values from files and inputs and extract their symbolic meaning.
</p>

<p>
Enums are fundamental to symbolic computation.
</p>

<p>
Enum work good for switch cases, if statements, for loops.
</p>

<p>
Enums are good for representing the type of something or a category.
</p>
</div>

<div id="outline-container-orgb53bdb3" class="outline-4">
<h4 id="orgb53bdb3"><span class="section-number-4">1.6.1</span> Enum Example</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
Enums are good for representing states, symbols, simple values, etc.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">N_DIRECTIONS</span> 4
<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">direction</span> {
    <span style="color: #a0522d;">UP</span>, <span style="color: #a0522d;">DOWN</span>, <span style="color: #a0522d;">LEFT</span>, <span style="color: #a0522d;">RIGHT</span>
};
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">direction</span> <span style="color: #228b22;">Direction</span>;

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">direction_names</span>[N_DIRECTIONS] = {
    [UP] = <span style="color: #8b2252;">"Up"</span>,
    [LEFT] = <span style="color: #8b2252;">"Left"</span>,
    [DOWN] = <span style="color: #8b2252;">"Down"</span>,
    [RIGHT] = <span style="color: #8b2252;">"Right"</span>
};

<span style="color: #228b22;">Direction</span> <span style="color: #0000ff;">clockwise</span>(<span style="color: #228b22;">Direction</span> <span style="color: #a0522d;">direction</span>) {
    <span style="color: #a020f0;">switch</span> (direction) {
        <span style="color: #a020f0;">case</span> UP:
            <span style="color: #a020f0;">return</span> RIGHT;
        <span style="color: #a020f0;">case</span> RIGHT:
            <span style="color: #a020f0;">return</span> DOWN;
        <span style="color: #a020f0;">case</span> DOWN:
            <span style="color: #a020f0;">return</span> LEFT;
        <span style="color: #a020f0;">case</span> LEFT:
            <span style="color: #a020f0;">return</span> UP;
        <span style="color: #a020f0;">default</span>:
            abort();
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Direction</span> <span style="color: #a0522d;">d</span> = UP;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; 10; i++) {
        d = clockwise(d);
        printf(<span style="color: #8b2252;">"%d %s\t[%d]\n"</span>, i, direction_names[d], d);
    }
}
</pre>
</div>

<pre class="example">
0 Right	[3]
1 Down	[1]
2 Left	[2]
3 Up	[0]
4 Right	[3]
5 Down	[1]
6 Left	[2]
7 Up	[0]
8 Right	[3]
9 Down	[1]
</pre>
</div>
</div>

<div id="outline-container-orga2355a9" class="outline-4">
<h4 id="orga2355a9"><span class="section-number-4">1.6.2</span> enum<sub>typedef.c</sub></h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
Enums are annoying to type. Typing enum enumname all the time is repetitive.
Typedefs allow us to label enum types with 1 word.
</p>

<p>
Typedef this 
</p>

<p>
enum enumname { &#x2026; } ;
</p>

<p>
with:
</p>

<p>
typedef enum enunumae Enumename ;
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span>,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">favourite</span> = VANILLA;
    printf(<span style="color: #8b2252;">"favourite=%d\n"</span>, favourite);
    printf(<span style="color: #8b2252;">"sizeof(favourite)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(favourite));

    <span style="color: #a020f0;">switch</span> (favourite) {
        <span style="color: #a020f0;">case</span> VANILLA:
            printf(<span style="color: #8b2252;">"favourite=VANILLA\n"</span>);
            <span style="color: #a020f0;">break</span>;
        <span style="color: #a020f0;">case</span> CHOCOLATE:
            printf(<span style="color: #8b2252;">"favourite=CHOCOLATE\n"</span>);
            <span style="color: #a020f0;">break</span>;
        <span style="color: #a020f0;">case</span> STRAWBERRY:
            printf(<span style="color: #8b2252;">"favourite=STRAWBERRY\n"</span>);
            <span style="color: #a020f0;">break</span>;
        <span style="color: #a020f0;">default</span>:
            abort();
    }
}
</pre>
</div>

<pre class="example">
favourite=0
sizeof(favourite)=4
favourite=VANILLA

</pre>
</div>
</div>



<div id="outline-container-org001d19a" class="outline-4">
<h4 id="org001d19a"><span class="section-number-4">1.6.3</span> EnumStart</h4>
<div class="outline-text-4" id="text-1-6-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span> = 100,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"VANILLA=%d\n"</span>, VANILLA);
    printf(<span style="color: #8b2252;">"CHOCOLATE=%d\n"</span>, CHOCOLATE);
    printf(<span style="color: #8b2252;">"STRAWBERRY=%d\n"</span>, STRAWBERRY);
    printf(<span style="color: #8b2252;">"sizeof(Flavor)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(Flavor));
}
</pre>
</div>

<pre class="example">
VANILLA=100
CHOCOLATE=101
STRAWBERRY=102
sizeof(Flavor)=4

</pre>
</div>
</div>

<div id="outline-container-org86e90ee" class="outline-4">
<h4 id="org86e90ee"><span class="section-number-4">1.6.4</span> Enumassign</h4>
<div class="outline-text-4" id="text-1-6-4">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span> = 100,
    <span style="color: #a0522d;">CHOCOLATE</span> = 200,
    <span style="color: #a0522d;">STRAWBERRY</span> = 300,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"VANILLA=%d\n"</span>, VANILLA);
    printf(<span style="color: #8b2252;">"CHOCOLATE=%d\n"</span>, CHOCOLATE);
    printf(<span style="color: #8b2252;">"STRAWBERRY=%d\n"</span>, STRAWBERRY);
    printf(<span style="color: #8b2252;">"sizeof(Flavor)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(Flavor));
}
</pre>
</div>

<pre class="example">
VANILLA=100
CHOCOLATE=200
STRAWBERRY=300
sizeof(Flavor)=4

</pre>
</div>
</div>

<div id="outline-container-org70bdbae" class="outline-4">
<h4 id="org70bdbae"><span class="section-number-4">1.6.5</span> Enum<sub>loop</sub><sub>trick.c</sub></h4>
<div class="outline-text-4" id="text-1-6-5">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">this only works as long as we don't provide our</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">own values!</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span>,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
    <span style="color: #a0522d;">N_FLAVORS</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">Get the free max enum here</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    printf(<span style="color: #8b2252;">"VANILLA=%d\n"</span>, VANILLA);
    printf(<span style="color: #8b2252;">"CHOCOLATE=%d\n"</span>, CHOCOLATE);
    printf(<span style="color: #8b2252;">"STRAWBERRY=%d\n"</span>, STRAWBERRY);
    printf(<span style="color: #8b2252;">"N_FLAVORS=%d\n"</span>, N_FLAVORS);
    printf(<span style="color: #8b2252;">"sizeof(Flavor)=%zu\n"</span>,
           <span style="color: #a020f0;">sizeof</span>(Flavor));

    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span> = 0; flavor &lt; N_FLAVORS; flavor++) {
        <span style="color: #a020f0;">switch</span> (flavor) {
            <span style="color: #a020f0;">case</span> VANILLA:
                printf(<span style="color: #8b2252;">"flavor=VANILLA\n"</span>);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> CHOCOLATE:
                printf(<span style="color: #8b2252;">"flavor=CHOCOLATE\n"</span>);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">case</span> STRAWBERRY:
                printf(<span style="color: #8b2252;">"flavor=STRAWBERRY\n"</span>);
                <span style="color: #a020f0;">break</span>;
            <span style="color: #a020f0;">default</span>:
                abort();
        }
    }
}
</pre>
</div>

<pre class="example">
VANILLA=0
CHOCOLATE=1
STRAWBERRY=2
N_FLAVORS=3
sizeof(Flavor)=4
flavor=VANILLA
flavor=CHOCOLATE
flavor=STRAWBERRY

</pre>
</div>
</div>

<div id="outline-container-org6ff2edc" class="outline-4">
<h4 id="org6ff2edc"><span class="section-number-4">1.6.6</span> Enum Int</h4>
<div class="outline-text-4" id="text-1-6-6">
<p>
This is a fun trick to set a maximum value for your enum by using
another symbol
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> {
    <span style="color: #a0522d;">VANILLA</span>,
    <span style="color: #a0522d;">CHOCOLATE</span>,
    <span style="color: #a0522d;">STRAWBERRY</span>,
    <span style="color: #a0522d;">N_FLAVORS</span> <span style="color: #b22222;">// </span><span style="color: #b22222;">LOOK MA! No Defines! Cute trick, might surprise people.</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">flavor</span> <span style="color: #228b22;">Flavor</span>;

<span style="color: #b22222;">// </span><span style="color: #b22222;">Here we use the fact that enums are really just ints!</span>
<span style="color: #228b22;">Flavor</span> <span style="color: #0000ff;">random_flavor</span>() {
    <span style="color: #a020f0;">return</span> (rand() % N_FLAVORS);
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">check_flavor</span>(<span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span>) {
    <span style="color: #a020f0;">if</span> (flavor &gt;= N_FLAVORS) {
        abort();
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Since a flavor is just an int, it could be negative...</span>
    <span style="color: #a020f0;">if</span> (flavor &lt; 0) {
        abort();
    }
}

<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #0000ff;">get_flavor_name</span>(<span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span>) {
    check_flavor(flavor);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Here we use "Designated Initializers"!</span>
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #a020f0;">const</span> <span style="color: #a0522d;">flavor_names</span>[N_FLAVORS] = {
        [CHOCOLATE] = <span style="color: #8b2252;">"Hamburger flavor"</span>,
        [VANILLA] = <span style="color: #8b2252;">"Raspberry"</span>,
        [STRAWBERRY] = <span style="color: #8b2252;">"Those packets that come in the ramen"</span>
    };
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">flavor_name</span> = flavor_names[flavor];
<span style="color: #b22222;">//     </span><span style="color: #b22222;">if (flavor_name == NULL) {</span>
<span style="color: #b22222;">//         </span><span style="color: #b22222;">printf("Flavor not found!\n");</span>
<span style="color: #b22222;">//         </span><span style="color: #b22222;">abort();</span>
<span style="color: #b22222;">//     </span><span style="color: #b22222;">}</span>
    <span style="color: #a020f0;">return</span> flavor_name;
}



<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #228b22;">Flavor</span> <span style="color: #a0522d;">flavor</span> = random_flavor();
    printf(
        <span style="color: #8b2252;">"flavor %d = %s\n"</span>,
        flavor,
        get_flavor_name(flavor)
    );
}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abram Hindle</p>
<p class="date">Created: 2020-03-10 Tue 10:09</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
