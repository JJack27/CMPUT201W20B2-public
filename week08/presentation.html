<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-03-10 Tue 10:14 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CMPUT201W20B2 Week 8</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Abram Hindle" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">CMPUT201W20B2 Week 8</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd7c6937">1. Week8</a>
<ul>
<li><a href="#org365b871">1.1. Copyright Statement</a>
<ul>
<li><a href="#org191c4af">1.1.1. License</a></li>
<li><a href="#orgc17184e">1.1.2. Hazel Code is licensed under AGPL3.0+</a></li>
</ul>
</li>
<li><a href="#org32017a4">1.2. Init ORG-MODE</a>
<ul>
<li><a href="#org467edb2">1.2.1. Org export</a></li>
</ul>
</li>
<li><a href="#orgef2f7f1">1.3. Org Template</a></li>
<li><a href="#org104d47a">1.4. Remember how to compile?</a></li>
<li><a href="#org5ad0596">1.5. Malloc continued!</a>
<ul>
<li><a href="#org8db7022">1.5.1. free</a></li>
<li><a href="#org2f3e6b6">1.5.2. Malloc and structs</a></li>
<li><a href="#org8093288">1.5.3. Malloc Array of Array versus 2D</a></li>
<li><a href="#orgfd83e99">1.5.4. Malloc array of arrays structs?</a></li>
<li><a href="#orgb5283c9">1.5.5. Using pointers for protection</a></li>
</ul>
</li>
<li><a href="#orgdf9b80c">1.6. Objects and APIs</a>
<ul>
<li><a href="#org6c7a3ea">1.6.1. original stack example</a></li>
<li><a href="#orge64e1bd">1.6.2. Recommended stack example</a></li>
<li><a href="#org586c3d2">1.6.3. Test First Top Down Design</a></li>
</ul>
</li>
<li><a href="#org97a01fd">1.7. Recursive Definitions</a>
<ul>
<li><a href="#org3024025">1.7.1. Mutually Recursive functions</a></li>
<li><a href="#org6d2760b">1.7.2. Recursive Structs</a></li>
<li><a href="#org7aef771">1.7.3. Mutually Recursive Structs</a></li>
</ul>
</li>
<li><a href="#org7226b43">1.8. Debugging</a>
<ul>
<li><a href="#org67dfee0">1.8.1. GDB</a></li>
<li><a href="#orgedc0ee3">1.8.2. valgrind</a></li>
<li><a href="#org994f210">1.8.3. More bad code</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgd7c6937" class="outline-2">
<h2 id="orgd7c6937"><span class="section-number-2">1</span> Week8</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org365b871" class="outline-3">
<h3 id="org365b871"><span class="section-number-3">1.1</span> Copyright Statement</h3>
<div class="outline-text-3" id="text-1-1">
<p>
If you are in CMPUT201 at UAlberta this code is released in the public
domain to you.
</p>

<p>
Otherwise it is (c) 2020 Abram Hindle, Hazel Campbell AGPL3.0+
</p>
</div>

<div id="outline-container-org191c4af" class="outline-4">
<h4 id="org191c4af"><span class="section-number-4">1.1.1</span> License</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Week 3 notes
Copyright (C) 2020 Abram Hindle, Hazel Campbell
</p>

<p>
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.
</p>

<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.
</p>

<p>
You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
</p>
</div>
</div>


<div id="outline-container-orgc17184e" class="outline-4">
<h4 id="orgc17184e"><span class="section-number-4">1.1.2</span> Hazel Code is licensed under AGPL3.0+</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
Hazel's code is also found here
<a href="https://github.com/hazelybell/examples/tree/C-2020-01">https://github.com/hazelybell/examples/tree/C-2020-01</a>
</p>

<p>
Hazel code is licensed: The example code is licensed under the AGPL3+
license, unless otherwise noted.
</p>
</div>
</div>
</div>

<div id="outline-container-org32017a4" class="outline-3">
<h3 id="org32017a4"><span class="section-number-3">1.2</span> Init ORG-MODE</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">
<pre class="src src-elisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">I need this for org-mode to work well</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">If we have a new org-mode use ob-shell</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">otherwise use ob-sh --- but not both!</span>
(<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">ob-shell</span> nil 'noerror)
  (<span style="color: #a020f0;">progn</span>
    (org-babel-do-load-languages 'org-babel-load-languages '((shell . t))))
  (<span style="color: #a020f0;">progn</span>
    (<span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">ob-sh</span>)
    (org-babel-do-load-languages 'org-babel-load-languages '((sh . t)))))
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
(<span style="color: #a020f0;">setq</span> org-src-fontify-natively t)
(<span style="color: #a020f0;">setq</span> org-confirm-babel-evaluate nil) <span style="color: #b22222;">;; </span><span style="color: #b22222;">danger!</span>
(custom-set-faces
 '(org-block ((t (<span style="color: #483d8b;">:inherit</span> shadow <span style="color: #483d8b;">:foreground</span> <span style="color: #8b2252;">"black"</span>)))))
</pre>
</div>
</div>

<div id="outline-container-org467edb2" class="outline-4">
<h4 id="org467edb2"><span class="section-number-4">1.2.1</span> Org export</h4>
<div class="outline-text-4" id="text-1-2-1">
<div class="org-src-container">
<pre class="src src-elisp">(org-html-export-to-html)
(org-latex-export-to-pdf)
(org-ascii-export-to-ascii)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgef2f7f1" class="outline-3">
<h3 id="orgef2f7f1"><span class="section-number-3">1.3</span> Org Template</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Copy and paste this to demo C
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span>**<span style="color: #a0522d;">argv</span>) {
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org104d47a" class="outline-3">
<h3 id="org104d47a"><span class="section-number-3">1.4</span> Remember how to compile?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
gcc  -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o programname programname.c
</p>
</div>
</div>

<div id="outline-container-org5ad0596" class="outline-3">
<h3 id="org5ad0596"><span class="section-number-3">1.5</span> Malloc continued!</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Continued.
</p>
</div>

<div id="outline-container-org8db7022" class="outline-4">
<h4 id="org8db7022"><span class="section-number-4">1.5.1</span> free</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
What happens if we don't free?
</p>

<p>
Our program can get bigger!
</p>



<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #228b22;">int</span> * <span style="color: #0000ff;">testAllocArray</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">arrLen</span>) {
  <span style="color: #228b22;">int</span>* <span style="color: #a0522d;">array</span> = calloc( <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>), arrLen );
  assert(array!=<span style="color: #008b8b;">NULL</span>);
  <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">idx</span>=0; idx&lt;arrLen; idx++) {
    array[idx] = idx;
  }
  <span style="color: #a020f0;">return</span> array;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1; i &lt; 10000000; i+=1*1024*1024) {
        <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">bigArray</span> = testAllocArray( i );
        printf(<span style="color: #8b2252;">"%u ints allocated!\n"</span>,1+bigArray[i-1]);
        printf(<span style="color: #8b2252;">"%lu bytes!\n"</span>, <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>)*i);
        <span style="color: #b22222;">// </span><span style="color: #b22222;">free(bigArray); // remember to free it when done!</span>
    }
}
</pre>
</div>

<pre class="example">
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
</pre>

<p>
Valgrind is a memory leak detector. It analyzes memory allocations and
warns us about mistakes.
</p>

<p>
Valgrind will show us that we're leaking memory (losing track of it
and not freeing it).
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -Wall -pedantic -Werror -o nofree ./nofree.c
valgrind ./nofree 2&gt;&amp;1
<span style="color: #483d8b;">echo</span> now let<span style="color: #8b2252;">\'</span>s leak check
valgrind --leak-check=full ./nofree 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==28799== Memcheck, a memory error detector
==28799== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==28799== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==28799== Command: ./nofree
==28799== 
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
==28799== 
==28799== HEAP SUMMARY:
==28799==     in use at exit: 188,743,720 bytes in 10 blocks
==28799==   total heap usage: 11 allocs, 1 frees, 188,747,816 bytes allocated
==28799== 
==28799== LEAK SUMMARY:
==28799==    definitely lost: 100,663,320 bytes in 6 blocks
==28799==    indirectly lost: 0 bytes in 0 blocks
==28799==      possibly lost: 88,080,400 bytes in 4 blocks
==28799==    still reachable: 0 bytes in 0 blocks
==28799==         suppressed: 0 bytes in 0 blocks
==28799== Rerun with --leak-check=full to see details of leaked memory
==28799== 
==28799== For counts of detected and suppressed errors, rerun with: -v
==28799== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
now let's leak check
==28801== Memcheck, a memory error detector
==28801== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==28801== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==28801== Command: ./nofree
==28801== 
1 ints allocated!
4 bytes!
1048577 ints allocated!
4194308 bytes!
2097153 ints allocated!
8388612 bytes!
3145729 ints allocated!
12582916 bytes!
4194305 ints allocated!
16777220 bytes!
5242881 ints allocated!
20971524 bytes!
6291457 ints allocated!
25165828 bytes!
7340033 ints allocated!
29360132 bytes!
8388609 ints allocated!
33554436 bytes!
9437185 ints allocated!
37748740 bytes!
==28801== 
==28801== HEAP SUMMARY:
==28801==     in use at exit: 188,743,720 bytes in 10 blocks
==28801==   total heap usage: 11 allocs, 1 frees, 188,747,816 bytes allocated
==28801== 
==28801== 88,080,400 bytes in 4 blocks are possibly lost in loss record 1 of 2
==28801==    at 0x4C31B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==28801==    by 0x1086F6: testAllocArray (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==28801==    by 0x10876F: main (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==28801== 
==28801== 100,663,320 bytes in 6 blocks are definitely lost in loss record 2 of 2
==28801==    at 0x4C31B25: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==28801==    by 0x1086F6: testAllocArray (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==28801==    by 0x10876F: main (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week07/nofree)
==28801== 
==28801== LEAK SUMMARY:
==28801==    definitely lost: 100,663,320 bytes in 6 blocks
==28801==    indirectly lost: 0 bytes in 0 blocks
==28801==      possibly lost: 88,080,400 bytes in 4 blocks
==28801==    still reachable: 0 bytes in 0 blocks
==28801==         suppressed: 0 bytes in 0 blocks
==28801== 
==28801== For counts of detected and suppressed errors, rerun with: -v
==28801== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
</pre>
</div>
</div>

<div id="outline-container-org2f3e6b6" class="outline-4">
<h4 id="org2f3e6b6"><span class="section-number-4">1.5.2</span> Malloc and structs</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
Mallocs are often used with arrays of structs. You need to get the
sizeof the struct.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACES</span> 13
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACEOFF</span> 1

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NSUIT</span> 4

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">PlayingCard</span> <span style="color: #0000ff;">randomCard</span>() {
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">card</span> = {ACE, CLUBS};
    card.face = NFACEOFF + ( rand() % NFACES );
    card.suit =  rand() % NSUIT;
    <span style="color: #a020f0;">return</span> card;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">N</span> = 1000000;
    <span style="color: #228b22;">PlayingCard</span> * <span style="color: #a0522d;">bigHand</span> = malloc(<span style="color: #a020f0;">sizeof</span>(PlayingCard)*N);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; N; i++) {
        bigHand[i] = randomCard();
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flushes</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; N - HANDSIZE; i+=HANDSIZE) {
        <span style="color: #a020f0;">if</span> (isFlush(bigHand + i)) {
            <span style="color: #a020f0;">if</span> (flushes &lt; 10) { <span style="color: #b22222;">// </span><span style="color: #b22222;">reduce printing</span>
                printf(<span style="color: #8b2252;">"Flush found at card %d\n"</span>, i);
                printf(<span style="color: #8b2252;">"Suit %d\n"</span>, bigHand[i].suit);
            }
            flushes++;
        }
    }
    printf(<span style="color: #8b2252;">"We found %d flushes out of %d hands: %f\n"</span>, flushes, N/HANDSIZE, flushes/(<span style="color: #228b22;">float</span>)(N/HANDSIZE));
}


</pre>
</div>

<pre class="example">
Flush found at card 225
Suit 2
Flush found at card 1370
Suit 1
Flush found at card 4095
Suit 1
Flush found at card 8160
Suit 1
Flush found at card 8665
Suit 0
Flush found at card 10025
Suit 1
Flush found at card 12900
Suit 0
Flush found at card 13085
Suit 0
Flush found at card 14855
Suit 3
Flush found at card 15145
Suit 2
We found 799 flushes out of 200000 hands: 0.003995
</pre>
</div>
</div>


<div id="outline-container-org8093288" class="outline-4">
<h4 id="org8093288"><span class="section-number-4">1.5.3</span> Malloc Array of Array versus 2D</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
So instead of allocating a big block and carving a 2D array out of it
we could just allocate each row and make an array of arrays.
</p>

<p>
Try playing with the order of allocation of rows. Does it affect the result?
</p>


<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">This example compares using malloc to get space for a 2-D array vs using malloc to make space for a array of arrays.</span>

<span style="color: #228b22;">int</span> * <span style="color: #0000ff;">alloc2d</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we can just do 1 malloc()</span>
    <span style="color: #a020f0;">return</span> (<span style="color: #228b22;">int</span> *) malloc(n * n * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>));
}

<span style="color: #228b22;">int</span> ** <span style="color: #0000ff;">alloc_aoa</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we have to do 1 + n malloc()s</span>
    <span style="color: #228b22;">int</span> ** <span style="color: #a0522d;">p</span> = malloc(<span style="color: #228b22;">n</span> * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span> *));
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we don't need to do them in order...</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        p[i] = malloc(<span style="color: #228b22;">n</span> * <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">int</span>));
    }
    <span style="color: #a020f0;">return</span> p;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">free2d</span>(<span style="color: #228b22;">int</span> * <span style="color: #a0522d;">p</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we can just do 1 free()</span>
    free(p);
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">free_aoa</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">int</span> ** <span style="color: #a0522d;">p</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">we have to do n + 1 free()s</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        free(p[i]);
    }
    free(p);
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get2d</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>) {
    <span style="color: #a020f0;">return</span> p[i * n + j];
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">get_aoa</span>(<span style="color: #228b22;">int</span> **<span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>) {
    <span style="color: #a020f0;">return</span> p[i][j];
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">set2d</span>(<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>, <span style="color: #228b22;">int</span> * <span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">v</span>) {
    <span style="color: #a020f0;">return</span> p[i * n + j] = v;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">set_aoa</span>(<span style="color: #228b22;">int</span> **<span style="color: #a0522d;">p</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span>, <span style="color: #228b22;">int</span> <span style="color: #a0522d;">v</span>) {
    <span style="color: #a020f0;">return</span> p[i][j] = v;
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">argc</span>, <span style="color: #228b22;">char</span> **<span style="color: #a0522d;">argv</span>) {
    srand(1);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">printf("I'm going to make space for a big, square table in memory.\n");</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">printf("How many rows and columns would you like to make space for? ");</span>
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">n</span>;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">int r = scanf("%zu", &amp;n);</span>
    n = 30;
    <span style="color: #a020f0;">if</span> (n != 1) {
        printf(<span style="color: #8b2252;">"Sorry, I couldn't understand that :(\n"</span>);
        exit(1);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">allocate them</span>
    <span style="color: #228b22;">int</span> *<span style="color: #a0522d;">p2d</span> = alloc2d(n);
    <span style="color: #228b22;">int</span> **<span style="color: #a0522d;">aoa</span> = alloc_aoa(n);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">initialize them</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            set2d(n, p2d, i, j, rand() % 10);
            set_aoa(aoa, i, j, rand() % 10);
        }
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">print them out</span>
    printf(<span style="color: #8b2252;">"2d:\n"</span>);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span> = get2d(n, p2d, i, j);
            printf(<span style="color: #8b2252;">"%d "</span>, x);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
    printf(<span style="color: #8b2252;">"aoa:\n"</span>);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; n; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; n; j++) {
            <span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span> = get_aoa(aoa, i, j);
            printf(<span style="color: #8b2252;">"%d "</span>, x);
        }
        printf(<span style="color: #8b2252;">"\n"</span>);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">free them</span>
    free2d(p2d);
    free_aoa(n, aoa);
}
</pre>
</div>

<pre class="example">
I'm going to make space for a big, square table in memory.
How many rows and columns would you like to make space for? Sorry, I couldn't understand that :(
2d:
3 7 3 6 9 2 0 3 0 2 1 7 2 2 7 9 2 9 3 1 9 1 4 8 5 3 1 6 2 6 
5 4 6 6 3 4 2 4 4 3 7 6 8 3 4 2 6 9 6 4 5 4 7 7 7 2 1 6 5 4 
0 1 7 1 9 7 7 6 6 9 8 2 3 0 8 0 6 8 6 1 9 4 1 3 4 4 7 3 7 9 
2 7 5 4 8 9 5 8 3 8 6 3 3 6 4 8 9 7 4 0 0 2 4 5 4 9 2 7 5 8 
2 9 6 0 1 5 1 8 0 4 2 8 2 4 2 0 2 9 8 3 1 3 0 9 9 9 3 0 6 4 
0 6 6 5 9 7 8 9 6 2 6 3 1 9 1 9 0 5 7 4 0 2 6 0 2 2 5 2 0 8 
8 4 9 9 2 4 9 3 0 0 9 3 1 4 1 6 4 2 4 2 8 2 8 6 3 3 3 0 7 8 
0 8 9 3 3 3 6 2 5 7 6 4 0 8 0 6 4 9 9 8 0 7 9 5 9 5 4 9 5 3 
7 8 9 7 2 3 9 2 1 6 1 0 3 1 0 6 7 0 4 4 5 2 0 6 6 8 6 7 1 1 
7 2 4 2 2 0 9 5 0 7 8 0 6 6 9 5 7 5 3 3 9 7 7 1 0 8 5 4 7 3 
0 7 9 2 3 1 2 2 7 1 4 7 1 7 4 8 1 6 1 6 8 8 0 2 7 6 6 7 7 9 
7 6 8 3 4 5 1 5 9 3 5 2 7 3 6 6 3 4 9 2 8 0 4 6 7 3 3 5 0 7 
3 0 0 1 3 9 4 5 8 5 5 9 7 3 6 5 6 0 1 2 9 0 2 4 3 8 3 0 3 9 
7 2 2 4 8 0 9 2 1 3 2 4 1 5 1 9 1 3 7 8 7 4 4 1 8 2 9 6 6 9 
0 9 1 8 6 7 7 2 1 0 0 0 3 4 1 0 2 7 6 4 2 7 4 6 7 5 2 3 4 9 
2 1 3 2 5 5 0 4 6 2 8 5 6 8 7 2 0 8 5 7 8 3 7 7 9 1 0 9 8 3 
0 9 1 7 7 2 1 8 4 6 6 4 8 8 5 4 0 7 2 2 3 9 1 5 4 2 1 2 2 9 
4 5 1 0 1 7 9 1 7 0 0 5 9 1 1 0 8 4 2 4 9 2 9 0 4 9 5 6 3 9 
2 3 9 1 4 8 7 3 9 5 8 0 3 1 7 5 1 3 0 5 2 9 9 9 1 3 3 4 1 6 
7 2 2 1 4 8 3 7 3 2 3 6 1 6 0 5 5 9 8 2 9 1 0 6 9 8 8 3 0 5 
3 8 1 9 0 5 4 4 9 9 3 3 7 4 9 9 2 6 9 6 1 3 2 3 9 4 4 9 8 2 
5 3 4 5 7 9 7 7 9 5 4 7 3 2 2 3 1 8 0 2 9 9 3 8 6 7 7 1 0 4 
3 3 7 1 9 6 9 5 1 9 1 2 0 3 1 7 8 0 4 3 9 4 5 2 7 8 9 3 8 4 
6 8 5 1 6 8 6 5 6 1 3 5 6 4 6 7 3 9 0 2 9 3 5 7 7 6 4 3 2 6 
9 5 3 4 1 1 9 5 2 9 7 4 1 1 8 4 3 3 7 3 8 0 8 8 3 5 5 2 8 2 
3 7 7 6 2 7 3 2 5 7 9 1 4 5 8 3 5 1 5 0 8 9 9 6 5 5 0 2 9 2 
6 5 8 7 6 2 9 0 7 5 4 0 8 4 4 8 2 6 2 7 4 6 4 4 5 6 3 7 2 0 
9 1 4 5 2 0 3 1 5 4 0 3 9 4 3 2 5 8 1 1 8 3 9 5 4 6 2 0 3 7 
3 1 4 1 6 3 7 0 4 3 7 9 3 2 9 5 0 3 9 5 3 2 7 7 0 6 5 8 9 7 
0 1 3 7 2 1 3 8 8 8 8 9 3 4 7 3 6 2 2 5 4 4 1 3 8 3 9 4 1 0 
aoa:
6 5 5 2 1 7 9 6 6 6 8 9 0 3 5 2 8 7 6 2 3 9 7 4 0 6 0 3 0 1 
5 7 5 9 7 5 5 7 4 0 8 8 4 1 9 0 8 2 6 9 0 8 1 2 2 6 0 1 9 9 
9 7 1 5 7 6 3 5 3 4 1 9 9 8 5 9 3 5 1 5 8 8 0 0 4 4 6 1 5 6 
1 8 7 1 5 7 3 8 1 9 4 3 8 0 8 8 7 6 3 3 9 5 0 9 6 2 4 7 4 1 
8 3 8 2 0 1 0 5 6 6 5 6 8 7 4 6 9 0 1 1 0 4 3 1 6 3 8 5 6 0 
4 2 7 6 8 2 2 9 0 7 1 2 5 9 4 1 7 8 0 8 4 9 1 4 2 0 5 9 2 3 
0 0 1 6 5 4 9 6 5 2 4 5 7 3 4 9 2 6 1 8 9 8 8 8 8 3 8 4 6 9 
6 7 0 3 7 2 5 6 8 9 0 1 4 7 8 2 7 3 2 3 1 8 1 4 2 7 9 4 9 5 
0 1 9 8 5 4 0 0 9 2 2 7 1 9 5 7 4 6 7 8 8 6 6 4 2 9 0 0 0 3 
7 6 5 0 9 9 4 1 3 8 6 4 7 0 7 9 8 3 8 7 3 8 4 9 9 8 8 3 1 8 
9 9 3 4 7 2 0 1 5 7 1 1 1 0 0 5 6 2 9 4 0 1 2 9 5 4 3 9 4 1 
0 0 5 9 1 4 5 4 8 8 2 2 0 4 3 3 4 3 7 5 9 2 7 5 1 3 8 1 8 6 
5 8 4 1 5 3 1 0 3 6 9 0 6 7 1 0 5 8 2 6 1 4 7 0 2 0 7 0 4 2 
4 5 4 3 6 8 2 3 8 4 2 5 7 7 6 8 3 3 9 6 0 8 8 6 5 1 9 0 4 9 
8 3 4 9 7 3 1 2 5 9 4 1 7 1 3 3 1 5 5 2 1 2 1 5 8 9 7 6 7 7 
2 6 0 1 6 0 3 6 0 5 9 0 0 3 8 1 5 5 0 3 2 0 7 6 1 9 8 8 0 7 
6 2 7 9 6 7 5 8 5 5 8 8 3 7 2 5 5 3 7 1 4 4 9 7 1 2 6 0 2 7 
3 6 4 3 2 7 8 0 6 1 2 1 7 3 2 6 7 9 4 5 1 8 6 6 0 4 4 6 9 5 
1 0 9 3 5 5 3 8 5 3 6 3 6 8 0 1 0 0 4 4 4 9 4 8 6 9 3 6 5 1 
2 9 8 2 7 6 7 2 7 5 7 8 3 4 3 8 0 9 0 4 0 2 0 3 0 3 7 1 0 0 
1 0 7 1 3 9 8 6 2 0 0 3 9 9 1 4 0 5 5 1 4 7 7 3 2 4 9 3 3 9 
4 9 9 5 3 0 2 2 0 0 1 9 6 1 5 9 8 7 5 7 1 6 6 4 6 2 4 0 6 4 
7 4 2 7 5 8 5 2 5 9 6 1 5 2 9 6 2 6 3 6 0 8 1 9 3 0 2 1 7 1 
3 5 0 2 4 5 2 2 9 3 1 2 9 4 0 4 7 0 2 6 0 5 8 1 0 0 1 0 9 0 
3 4 6 3 9 0 4 6 5 1 7 1 9 3 7 9 1 8 9 8 4 0 6 2 8 0 9 6 5 8 
6 8 2 6 9 0 7 3 1 8 4 6 3 4 7 3 0 4 7 7 9 3 4 4 5 6 6 6 9 9 
5 3 6 3 0 6 3 8 6 2 0 6 5 9 6 3 3 2 4 0 9 5 6 2 1 1 7 1 1 8 
0 3 8 8 2 6 6 0 7 2 0 3 0 3 4 4 3 1 3 5 1 3 7 4 9 7 1 1 7 6 
9 0 1 8 4 4 7 7 5 0 2 9 0 7 9 2 8 5 6 6 0 0 4 3 1 7 7 8 0 8 
3 0 6 3 2 5 3 2 5 0 6 3 7 3 1 9 4 0 9 7 6 9 2 1 1 8 2 5 0 1
</pre>
</div>
</div>


<div id="outline-container-orgfd83e99" class="outline-4">
<h4 id="orgfd83e99"><span class="section-number-4">1.5.4</span> Malloc array of arrays structs?</h4>
<div class="outline-text-4" id="text-1-5-4">
<p>
Arrays of Arrays? Pointers?
</p>

<p>
X ** x?
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACES</span> 13
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACEOFF</span> 1

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NSUIT</span> 4

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">PlayingCard</span> <span style="color: #0000ff;">randomCard</span>() {
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">card</span> = {ACE, CLUBS};
    card.face = NFACEOFF + ( rand() % NFACES );
    card.suit =  rand() % NSUIT;
    <span style="color: #a020f0;">return</span> card;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">HANDS</span> = 1000000;
    <span style="color: #228b22;">PlayingCard</span> * <span style="color: #a0522d;">hands</span> = malloc(<span style="color: #a020f0;">sizeof</span>(PlayingCard)*HANDS*HANDSIZE);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS*HANDSIZE; i++) {
        hands[i] = randomCard();
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flushes</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #a020f0;">if</span> (isFlush(hands + i*HANDSIZE)) {
            <span style="color: #a020f0;">if</span> (flushes &lt; 10) { <span style="color: #b22222;">// </span><span style="color: #b22222;">reduce printing</span>
                printf(<span style="color: #8b2252;">"Flush found at card %d\n"</span>, i);
                printf(<span style="color: #8b2252;">"Suit %d\n"</span>, hands[i].suit);
            }
            flushes++;
        }
    }
    printf(<span style="color: #8b2252;">"We found %d flushes out of %d hands: %f\n"</span>, flushes, HANDS, flushes/(<span style="color: #228b22;">float</span>)(HANDS));
}


</pre>
</div>

<pre class="example">
Flush found at card 19
Suit 3
Flush found at card 340
Suit 1
Flush found at card 450
Suit 0
Flush found at card 870
Suit 0
Flush found at card 918
Suit 1
Flush found at card 932
Suit 2
Flush found at card 970
Suit 2
Flush found at card 1375
Suit 0
Flush found at card 1438
Suit 3
Flush found at card 1631
Suit 2
We found 3902 flushes out of 1000000 hands: 0.003902
</pre>

<p>
That's kind of gross, let's model our hands as arrays of 5 cards instead.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACES</span> 13
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACEOFF</span> 1

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NSUIT</span> 4

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">PlayingCard</span> <span style="color: #0000ff;">randomCard</span>() {
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">card</span> = {ACE, CLUBS};
    card.face = NFACEOFF + ( rand() % NFACES );
    card.suit =  rand() % NSUIT;
    <span style="color: #a020f0;">return</span> card;
}
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">HANDS</span> = 1000000;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Pointer to arrays</span>
    <span style="color: #228b22;">PlayingCard</span> (*<span style="color: #a0522d;">hands</span>)[5] = malloc(<span style="color: #a020f0;">sizeof</span>(PlayingCard[5])*HANDS);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 0; j &lt; HANDSIZE; j++) {
            hands[i][j] = randomCard();
        }
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flushes</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #a020f0;">if</span> (isFlush(hands[i])) {
            <span style="color: #a020f0;">if</span> (flushes &lt; 10) { <span style="color: #b22222;">// </span><span style="color: #b22222;">reduce printing</span>
                printf(<span style="color: #8b2252;">"Flush found at card %d\n"</span>, i);
                printf(<span style="color: #8b2252;">"Suit %d\n"</span>, hands[i][0].suit);
            }
            flushes++;
        }
    }
    printf(<span style="color: #8b2252;">"We found %d flushes out of %d hands: %f\n"</span>, flushes, HANDS, flushes/(<span style="color: #228b22;">float</span>)(HANDS));
}


</pre>
</div>

<pre class="example">
Flush found at card 223
Suit 0
Flush found at card 323
Suit 1
Flush found at card 335
Suit 3
Flush found at card 407
Suit 1
Flush found at card 896
Suit 3
Flush found at card 1027
Suit 3
Flush found at card 1124
Suit 0
Flush found at card 1279
Suit 0
Flush found at card 1301
Suit 0
Flush found at card 1734
Suit 3
We found 3855 flushes out of 1000000 hands: 0.003855
</pre>

<ul class="org-ul">
<li>Remember to tangle this to write to disk</li>
</ul>

<p>
<a href="./cards-aoa.c">./cards-aoa.c</a>
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span> 
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;time.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;assert.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> {
    <span style="color: #a0522d;">ACE</span> = 1,
    <span style="color: #a0522d;">FACE2</span>,
    <span style="color: #a0522d;">FACE3</span>,
    <span style="color: #a0522d;">FACE4</span>,
    <span style="color: #a0522d;">FACE5</span>,
    <span style="color: #a0522d;">FACE6</span>,
    <span style="color: #a0522d;">FACE7</span>,
    <span style="color: #a0522d;">FACE8</span>,
    <span style="color: #a0522d;">FACE9</span>,
    <span style="color: #a0522d;">FACE10</span>,
    <span style="color: #a0522d;">JACK</span>,
    <span style="color: #a0522d;">QUEEN</span>,
    <span style="color: #a0522d;">KING</span>,
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_face</span> <span style="color: #228b22;">CardFace</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACES</span> 13
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NFACEOFF</span> 1

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> {
    <span style="color: #a0522d;">CLUBS</span>,
    <span style="color: #a0522d;">HEARTS</span>,
    <span style="color: #a0522d;">DIAMONDS</span>,
    <span style="color: #a0522d;">SPADES</span>
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">card_suit</span> <span style="color: #228b22;">CardSuit</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NSUIT</span> 4

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> {
    <span style="color: #228b22;">CardFace</span> <span style="color: #a0522d;">face</span>;
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span>;
};

<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">playing_card</span> <span style="color: #228b22;">PlayingCard</span>;

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDSIZE</span> 5

<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">isFlush</span>(<span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #228b22;">CardSuit</span> <span style="color: #a0522d;">suit</span> = hand[0].suit;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 1;  i &lt; HANDSIZE; i++ ) {
        <span style="color: #a020f0;">if</span> (suit != hand[i].suit) {
            <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
        }
    }
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}

<span style="color: #228b22;">PlayingCard</span> <span style="color: #0000ff;">randomCard</span>() {
    <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">card</span> = {ACE, CLUBS};
    card.face = NFACEOFF + ( rand() % NFACES );
    card.suit =  rand() % NSUIT;
    <span style="color: #a020f0;">return</span> card;
}

<span style="color: #228b22;">PlayingCard</span> * <span style="color: #0000ff;">allocateHand</span>() {
    <span style="color: #228b22;">PlayingCard</span> * <span style="color: #a0522d;">hand</span> = malloc(<span style="color: #a020f0;">sizeof</span>(PlayingCard[HANDSIZE]));
    assert(hand!=<span style="color: #008b8b;">NULL</span>);
    <span style="color: #a020f0;">return</span> hand;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">randomizeHand</span>( <span style="color: #228b22;">PlayingCard</span> <span style="color: #a0522d;">hand</span>[HANDSIZE]) {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDSIZE; i++) {
        hand[i] = randomCard();
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    srand(time(<span style="color: #008b8b;">NULL</span>));
    <span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">HANDS</span> = 1000000;
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Pointer to arrays of arrays</span>
    <span style="color: #228b22;">PlayingCard</span> **<span style="color: #a0522d;">hands</span> = malloc(<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">PlayingCard</span>(*)[5]) * HANDS);
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = HANDS-1; i &gt;= 0; i--) {
        hands[i] = allocateHand();
        randomizeHand( hands[i] );
    }
    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">flushes</span> = 0;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #a020f0;">if</span> (isFlush(hands[i])) {
            <span style="color: #a020f0;">if</span> (flushes &lt; 10) { <span style="color: #b22222;">// </span><span style="color: #b22222;">reduce printing</span>
                printf(<span style="color: #8b2252;">"Flush found at card %d\n"</span>, i);
                printf(<span style="color: #8b2252;">"Suit %d\n"</span>, hands[i][0].suit);
            }
            flushes++;
        }
    }
    printf(<span style="color: #8b2252;">"We found %d flushes out of %d hands: %f\n"</span>, flushes, HANDS, flushes/(<span style="color: #228b22;">float</span>)(HANDS));
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; HANDS; i++) {
        <span style="color: #b22222;">// </span><span style="color: #b22222;">comment these out to try valgrind</span>
        free(hands[i]);
    }
    <span style="color: #b22222;">// </span><span style="color: #b22222;">comment these out to try valgrind</span>
    free(hands);
}


</pre>
</div>

<pre class="example">
Flush found at card 148
Suit 0
Flush found at card 792
Suit 2
Flush found at card 845
Suit 1
Flush found at card 1055
Suit 1
Flush found at card 1152
Suit 3
Flush found at card 1240
Suit 0
Flush found at card 1259
Suit 3
Flush found at card 1873
Suit 1
Flush found at card 2368
Suit 0
Flush found at card 2509
Suit 0
We found 4003 flushes out of 1000000 hands: 0.004003
</pre>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o cards-aoa ./cards-aoa.c
valgrind --leak-check=full ./cards-aoa 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==16946== Memcheck, a memory error detector
==16946== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==16946== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==16946== Command: ./cards-aoa
==16946== 
Flush found at card 14
Suit 0
Flush found at card 65
Suit 0
Flush found at card 126
Suit 1
Flush found at card 238
Suit 1
Flush found at card 246
Suit 1
Flush found at card 648
Suit 1
Flush found at card 738
Suit 2
Flush found at card 894
Suit 1
Flush found at card 1076
Suit 0
Flush found at card 1175
Suit 2
We found 3845 flushes out of 1000000 hands: 0.003845
==16946== 
==16946== HEAP SUMMARY:
==16946==     in use at exit: 0 bytes in 0 blocks
==16946==   total heap usage: 1,000,002 allocs, 1,000,002 frees, 48,004,096 bytes allocated
==16946== 
==16946== All heap blocks were freed -- no leaks are possible
==16946== 
==16946== For counts of detected and suppressed errors, rerun with: -v
==16946== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>
</div>
</div>


<div id="outline-container-orgb5283c9" class="outline-4">
<h4 id="orgb5283c9"><span class="section-number-4">1.5.5</span> Using pointers for protection</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
<a href="./stack.c">./stack.c</a>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_POSIX_C_SOURCE</span> 200809L <span style="color: #b22222;">// </span><span style="color: #b22222;">&lt;-- needed for getline</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">Let's define Stack as a pointer to a struct,</span>
<span style="color: #b22222;"> * which itself contains the pointer to the actual</span>
<span style="color: #b22222;"> * data on the stack, which are pointers to chars (strings).</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * This is so that when we realloc() and update elts,</span>
<span style="color: #b22222;"> * we don't have to worry about some other piece of code</span>
<span style="color: #b22222;"> * having the old value of elts.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * If we didn't hide our pointer that gets realloc'd behind</span>
<span style="color: #b22222;"> * another pointer, it is easy to have an old copy of the</span>
<span style="color: #b22222;"> * realloc'd pointer (which is now invalid) floating around.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * But by putting it behind a pointer, new_stack() can</span>
<span style="color: #b22222;"> * create the single copy of the struct, which contains</span>
<span style="color: #b22222;"> * the elts pointer that changes. Since the sizeof the</span>
<span style="color: #b22222;"> * actual struct never changes, we never have to realloc</span>
<span style="color: #b22222;"> * that pointer, so we can ensure we only have one version</span>
<span style="color: #b22222;"> * of elts at all times. This is similar to how</span>
<span style="color: #b22222;"> * Java/Python/JS handle arrays internally.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">OK so Stack is pointer of struct stack NOT struct stack.</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">stack</span> {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
    <span style="color: #228b22;">char</span> ** <span style="color: #a0522d;">elts</span>;
} * <span style="color: #228b22;">Stack</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">show_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    printf(<span style="color: #8b2252;">"Stack %p: %zu items starting at %p\n"</span>,
           (<span style="color: #228b22;">void</span> *) stack,
           stack-&gt;size,
           (<span style="color: #228b22;">void</span> *) stack-&gt;elts
    );
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">This is a good style, new_object, or object_create</span>
<span style="color: #228b22;">Stack</span> <span style="color: #0000ff;">new_stack</span>() {
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">Constructor </span><span style="color: #b22222;">*/</span>
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">new</span> = malloc(<span style="color: #a020f0;">sizeof</span>(*new));
    <span style="color: #a020f0;">if</span> (new == <span style="color: #008b8b;">NULL</span>) {
        abort();
    }
    new-&gt;size = 0;
    new-&gt;elts = <span style="color: #008b8b;">NULL</span>;
    show_stack(new);
    <span style="color: #a020f0;">return</span> new;
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">this function deduplicates code from push and pop </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">resize</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">new_size</span>) {
    stack-&gt;elts = realloc(
        stack-&gt;elts,
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">char</span> *) * new_size
    );
    
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">make sure any new elements are initialized </span><span style="color: #b22222;">*/</span>
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">first_new_elt</span> = stack-&gt;size;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">idx</span> = first_new_elt;
         idx &lt; new_size;
         idx++) {
        stack-&gt;elts[idx] = <span style="color: #008b8b;">NULL</span>;
    }
    
    stack-&gt;size = new_size;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">string</span>) {
    resize(stack, stack-&gt;size + 1);
    stack-&gt;elts[stack-&gt;size-1] = string;
    show_stack(stack);
}

<span style="color: #228b22;">char</span> * <span style="color: #0000ff;">pop</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    <span style="color: #a020f0;">if</span> (stack-&gt;size == 0) {
        abort();
    }
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">string</span> = stack-&gt;elts[stack-&gt;size-1];
    resize(stack, stack-&gt;size - 1);
    show_stack(stack);
    <span style="color: #a020f0;">return</span> string;
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">Destructor </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">free_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    resize(stack, 0);
    free(stack);
}

<span style="color: #228b22;">char</span> * <span style="color: #0000ff;">checked_getline</span>() {
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">alloc_len</span> = 0;
    <span style="color: #228b22;">ssize_t</span> <span style="color: #a0522d;">got</span> = getline(&amp;line, &amp;alloc_len, stdin);
    <span style="color: #a020f0;">if</span> (got &lt; 0) {
        <span style="color: #a020f0;">if</span> (line != <span style="color: #008b8b;">NULL</span>) {
            free(line);
        }
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
    } <span style="color: #a020f0;">else</span> {
        <span style="color: #a020f0;">return</span> line;
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_input_lines</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    printf(<span style="color: #8b2252;">"Enter some lines. Press ctrl-d (EOF) to end.\n"</span>);
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">while</span> ((line = checked_getline()) != <span style="color: #008b8b;">NULL</span>) {
        push(stack, line);
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">pop_lines</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    <span style="color: #a020f0;">while</span> (stack-&gt;size &gt; 0) {
        <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = pop(stack);
        puts(line);
        free(line);
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack1</span> = new_stack();
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack2</span> = stack1;
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Because stack is a pointer, stack1 and stack2 are </span>
<span style="color: #b22222;"> * actually the same stack!</span>
<span style="color: #b22222;"> * Because the actual struct doesn't need to change size,</span>
<span style="color: #b22222;"> * these pointers will be valid until we call free_stack()</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>
    push_input_lines(stack1);
    pop_lines(stack2);
    free_stack(stack1);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
Stack 0x56362ee8c260: 0 items starting at (nil)
Enter some lines. Press ctrl-d (EOF) to end.

</pre>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o stack ./stack.c
seq 9990 9999 | ./stack
</pre>
</div>

<pre class="example">
Stack 0x55f488145260: 0 items starting at (nil)
Enter some lines. Press ctrl-d (EOF) to end.
Stack 0x55f488145260: 1 items starting at 0x55f488147320
Stack 0x55f488145260: 2 items starting at 0x55f488147320
Stack 0x55f488145260: 3 items starting at 0x55f488147320
Stack 0x55f488145260: 4 items starting at 0x55f4881474c0
Stack 0x55f488145260: 5 items starting at 0x55f4881474c0
Stack 0x55f488145260: 6 items starting at 0x55f4881475f0
Stack 0x55f488145260: 7 items starting at 0x55f4881475f0
Stack 0x55f488145260: 8 items starting at 0x55f488147730
Stack 0x55f488145260: 9 items starting at 0x55f488147730
Stack 0x55f488145260: 10 items starting at 0x55f488147880
Stack 0x55f488145260: 9 items starting at 0x55f488147880
9999
Stack 0x55f488145260: 8 items starting at 0x55f488147880
9998
Stack 0x55f488145260: 7 items starting at 0x55f488147880
9997
Stack 0x55f488145260: 6 items starting at 0x55f488147880
9996
Stack 0x55f488145260: 5 items starting at 0x55f488147880
9995
Stack 0x55f488145260: 4 items starting at 0x55f488147880
9994
Stack 0x55f488145260: 3 items starting at 0x55f488147880
9993
Stack 0x55f488145260: 2 items starting at 0x55f488147880
9992
Stack 0x55f488145260: 1 items starting at 0x55f488147880
9991
Stack 0x55f488145260: 0 items starting at (nil)
9990
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdf9b80c" class="outline-3">
<h3 id="orgdf9b80c"><span class="section-number-3">1.6</span> Objects and APIs</h3>
<div class="outline-text-3" id="text-1-6">
<p>
When you make a new type you should follow some guidelines:
</p>

<ul class="org-ul">
<li>put the name of the type at the start or end of function names:
<ul class="org-ul">
<li>For type dog:
<ul class="org-ul">
<li>dog<sub>create</sub>()</li>
<li>dog<sub>free</sub>(dog)</li>
<li>dog<sub>move</sub>(dog,x,y)</li>
<li>dog<sub>bark</sub>(dog, bark<sub>spec</sub>)</li>
<li>createDog()</li>
<li>freeDog(dog)</li>
<li>moveDog(dog,x,y)</li>
<li>barkDog(dog, barkSpec)</li>
</ul></li>
<li>For type cat:
<ul class="org-ul">
<li>createCat()</li>
<li>freeCat(cat)</li>
<li>moveCat(cat)</li>
<li>meowCat(cat, meow<sub>spec</sub>)</li>
<li>cat<sub>create</sub>()</li>
<li>cat<sub>free</sub>(cat)</li>
<li>cat<sub>move</sub>(cat)</li>
<li>cat<sub>meow</sub>(cat, meow<sub>spec</sub>)</li>
</ul></li>
</ul></li>
<li>Should your type be a struct or a pointer to a struct?
<ul class="org-ul">
<li>struct pros:
<ul class="org-ul">
<li>functional</li>
<li>easy to copy</li>
<li>stay on the stack</li>
<li>safe shallow copy of data</li>
<li>don't have to free</li>
</ul></li>
<li>struct cons:
<ul class="org-ul">
<li>if structs have pointers then copies of structs might have old pointers</li>
<li>doesn't play well we malloc and realloc</li>
<li>stale info</li>
<li>hard to ensure consistency</li>
<li>big</li>
</ul></li>
<li>pointer to struct pros:
<ul class="org-ul">
<li>small to pass (1 pointer)</li>
<li>can have multiple references</li>
<li>more control</li>
<li>can hide implementation better</li>
<li>consistency</li>
<li>malloc and realloc friendly.</li>
</ul></li>
<li>pointer to struct cons:
<ul class="org-ul">
<li>malloc</li>
<li>must free</li>
<li>hard to copy</li>
<li>deepcopy required</li>
<li>awkward with arrays</li>
</ul></li>
</ul></li>
</ul>
</div>

<div id="outline-container-org6c7a3ea" class="outline-4">
<h4 id="org6c7a3ea"><span class="section-number-4">1.6.1</span> original stack example</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
<a href="./stack.c">./stack.c</a>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_POSIX_C_SOURCE</span> 200809L <span style="color: #b22222;">// </span><span style="color: #b22222;">&lt;-- needed for getline</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">Let's define Stack as a pointer to a struct,</span>
<span style="color: #b22222;"> * which itself contains the pointer to the actual</span>
<span style="color: #b22222;"> * data on the stack, which are pointers to chars (strings).</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * This is so that when we realloc() and update elts,</span>
<span style="color: #b22222;"> * we don't have to worry about some other piece of code</span>
<span style="color: #b22222;"> * having the old value of elts.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * If we didn't hide our pointer that gets realloc'd behind</span>
<span style="color: #b22222;"> * another pointer, it is easy to have an old copy of the</span>
<span style="color: #b22222;"> * realloc'd pointer (which is now invalid) floating around.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * But by putting it behind a pointer, new_stack() can</span>
<span style="color: #b22222;"> * create the single copy of the struct, which contains</span>
<span style="color: #b22222;"> * the elts pointer that changes. Since the sizeof the</span>
<span style="color: #b22222;"> * actual struct never changes, we never have to realloc</span>
<span style="color: #b22222;"> * that pointer, so we can ensure we only have one version</span>
<span style="color: #b22222;"> * of elts at all times. This is similar to how</span>
<span style="color: #b22222;"> * Java/Python/JS handle arrays internally.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">OK so Stack is pointer of struct stack NOT struct stack.</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">stack</span> {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
    <span style="color: #228b22;">char</span> ** <span style="color: #a0522d;">elts</span>;
} * <span style="color: #228b22;">Stack</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">show_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    printf(<span style="color: #8b2252;">"Stack %p: %zu items starting at %p\n"</span>,
           (<span style="color: #228b22;">void</span> *) stack,
           stack-&gt;size,
           (<span style="color: #228b22;">void</span> *) stack-&gt;elts
    );
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">This is a good style, new_object, or object_create</span>
<span style="color: #228b22;">Stack</span> <span style="color: #0000ff;">new_stack</span>() {
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">Constructor </span><span style="color: #b22222;">*/</span>
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">new</span> = malloc(<span style="color: #a020f0;">sizeof</span>(*new));
    new-&gt;size = 0;
    new-&gt;elts = <span style="color: #008b8b;">NULL</span>;
    show_stack(new);
    <span style="color: #a020f0;">return</span> new;
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">this function deduplicates code from push and pop </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">resize</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">new_size</span>) {
    stack-&gt;elts = realloc(
        stack-&gt;elts,
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">char</span> *) * new_size
    );
    
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">make sure any new elements are initialized </span><span style="color: #b22222;">*/</span>
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">first_new_elt</span> = stack-&gt;size;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">idx</span> = first_new_elt;
         idx &lt; new_size;
         idx++) {
        stack-&gt;elts[idx] = <span style="color: #008b8b;">NULL</span>;
    }
    
    stack-&gt;size = new_size;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">string</span>) {
    resize(stack, stack-&gt;size + 1);
    stack-&gt;elts[stack-&gt;size-1] = string;
    show_stack(stack);
}

<span style="color: #228b22;">char</span> * <span style="color: #0000ff;">pop</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    <span style="color: #a020f0;">if</span> (stack-&gt;size == 0) {
        abort();
    }
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">string</span> = stack-&gt;elts[stack-&gt;size-1];
    resize(stack, stack-&gt;size - 1);
    show_stack(stack);
    <span style="color: #a020f0;">return</span> string;
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">Destructor </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">free_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    resize(stack, 0);
    free(stack);
}

<span style="color: #228b22;">char</span> * <span style="color: #0000ff;">checked_getline</span>() {
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">alloc_len</span> = 0;
    <span style="color: #228b22;">ssize_t</span> <span style="color: #a0522d;">got</span> = getline(&amp;line, &amp;alloc_len, stdin);
    <span style="color: #a020f0;">if</span> (got &lt; 0) {
        <span style="color: #a020f0;">if</span> (line != <span style="color: #008b8b;">NULL</span>) {
            free(line);
        }
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
    } <span style="color: #a020f0;">else</span> {
        <span style="color: #a020f0;">return</span> line;
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_input_lines</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    printf(<span style="color: #8b2252;">"Enter some lines. Press ctrl-d (EOF) to end.\n"</span>);
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">while</span> ((line = checked_getline()) != <span style="color: #008b8b;">NULL</span>) {
        push(stack, line);
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">pop_lines</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    <span style="color: #a020f0;">while</span> (stack-&gt;size &gt; 0) {
        <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = pop(stack);
        puts(line);
        free(line);
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack1</span> = new_stack();
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack2</span> = stack1;
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Because stack is a pointer, stack1 and stack2 are </span>
<span style="color: #b22222;"> * actually the same stack!</span>
<span style="color: #b22222;"> * Because the actual struct doesn't need to change size,</span>
<span style="color: #b22222;"> * these pointers will be valid until we call free_stack()</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>
    push_input_lines(stack1);
    pop_lines(stack2);
    free_stack(stack1);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
Stack 0x55f01a3ba260: 0 items starting at (nil)
Enter some lines. Press ctrl-d (EOF) to end.

</pre>
</div>
</div>

<div id="outline-container-orge64e1bd" class="outline-4">
<h4 id="orge64e1bd"><span class="section-number-4">1.6.2</span> Recommended stack example</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
<a href="./new_stack.c">./new_stack.c</a>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_POSIX_C_SOURCE</span> 200809L <span style="color: #b22222;">// </span><span style="color: #b22222;">&lt;-- needed for getline</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">Let's define Stack as a pointer to a struct,</span>
<span style="color: #b22222;"> * which itself contains the pointer to the actual</span>
<span style="color: #b22222;"> * data on the stack, which are pointers to chars (strings).</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * This is so that when we realloc() and update elts,</span>
<span style="color: #b22222;"> * we don't have to worry about some other piece of code</span>
<span style="color: #b22222;"> * having the old value of elts.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * If we didn't hide our pointer that gets realloc'd behind</span>
<span style="color: #b22222;"> * another pointer, it is easy to have an old copy of the</span>
<span style="color: #b22222;"> * realloc'd pointer (which is now invalid) floating around.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> * But by putting it behind a pointer, new_stack() can</span>
<span style="color: #b22222;"> * create the single copy of the struct, which contains</span>
<span style="color: #b22222;"> * the elts pointer that changes. Since the sizeof the</span>
<span style="color: #b22222;"> * actual struct never changes, we never have to realloc</span>
<span style="color: #b22222;"> * that pointer, so we can ensure we only have one version</span>
<span style="color: #b22222;"> * of elts at all times. This is similar to how</span>
<span style="color: #b22222;"> * Java/Python/JS handle arrays internally.</span>
<span style="color: #b22222;"> * </span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>

<span style="color: #b22222;">// </span><span style="color: #b22222;">OK so Stack is pointer of struct stack NOT struct stack.</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">stack</span> {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
    <span style="color: #228b22;">char</span> ** <span style="color: #a0522d;">elts</span>;
} * <span style="color: #228b22;">Stack</span>;

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">show_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    printf(<span style="color: #8b2252;">"Stack %p: %zu items starting at %p\n"</span>,
           (<span style="color: #228b22;">void</span> *) stack,
           stack-&gt;size,
           (<span style="color: #228b22;">void</span> *) stack-&gt;elts
    );
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">This is a good style, new_object, or object_create</span>
<span style="color: #228b22;">Stack</span> <span style="color: #0000ff;">new_stack</span>() {
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">Constructor </span><span style="color: #b22222;">*/</span>
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">new</span> = malloc(<span style="color: #a020f0;">sizeof</span>(*new));
    new-&gt;size = 0;
    new-&gt;elts = <span style="color: #008b8b;">NULL</span>;
    show_stack(new);
    <span style="color: #a020f0;">return</span> new;
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">this function deduplicates code from push and pop </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">resize_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">new_size</span>) {
    stack-&gt;elts = realloc(
        stack-&gt;elts,
        <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">char</span> *) * new_size
    );
    
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">make sure any new elements are initialized </span><span style="color: #b22222;">*/</span>
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">first_new_elt</span> = stack-&gt;size;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">idx</span> = first_new_elt;
         idx &lt; new_size;
         idx++) {
        stack-&gt;elts[idx] = <span style="color: #008b8b;">NULL</span>;
    }
    
    stack-&gt;size = new_size;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">string</span>) {
    resize_stack(stack, stack-&gt;size + 1);
    stack-&gt;elts[stack-&gt;size-1] = string;
    show_stack(stack);
}

<span style="color: #228b22;">char</span> * <span style="color: #0000ff;">pop_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    <span style="color: #a020f0;">if</span> (stack-&gt;size == 0) {
        abort();
    }
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">string</span> = stack-&gt;elts[stack-&gt;size-1];
    resize_stack(stack, stack-&gt;size - 1);
    show_stack(stack);
    <span style="color: #a020f0;">return</span> string;
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">Destructor </span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">free_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    resize_stack(stack, 0);
    free(stack);
}

<span style="color: #228b22;">char</span> * <span style="color: #0000ff;">checked_getline</span>() {
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">alloc_len</span> = 0;
    <span style="color: #228b22;">ssize_t</span> <span style="color: #a0522d;">got</span> = getline(&amp;line, &amp;alloc_len, stdin);
    <span style="color: #a020f0;">if</span> (got &lt; 0) {
        <span style="color: #a020f0;">if</span> (line != <span style="color: #008b8b;">NULL</span>) {
            free(line);
        }
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
    } <span style="color: #a020f0;">else</span> {
        <span style="color: #a020f0;">return</span> line;
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">push_input_lines_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    printf(<span style="color: #8b2252;">"Enter some lines. Press ctrl-d (EOF) to end.\n"</span>);
    <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = <span style="color: #008b8b;">NULL</span>;
    <span style="color: #a020f0;">while</span> ((line = checked_getline()) != <span style="color: #008b8b;">NULL</span>) {
        push_stack(stack, line);
    }
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">pop_lines_stack</span>(<span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack</span>) {
    <span style="color: #a020f0;">while</span> (stack-&gt;size &gt; 0) {
        <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">line</span> = pop_stack(stack);
        puts(line);
        free(line);
    }
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack1</span> = new_stack();
    <span style="color: #228b22;">Stack</span> <span style="color: #a0522d;">stack2</span> = stack1;
<span style="color: #b22222;">/* </span><span style="color: #b22222;">Because stack is a pointer, stack1 and stack2 are </span>
<span style="color: #b22222;"> * actually the same stack!</span>
<span style="color: #b22222;"> * Because the actual struct doesn't need to change size,</span>
<span style="color: #b22222;"> * these pointers will be valid until we call free_stack()</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>
    push_input_lines_stack(stack1);
    pop_lines_stack(stack2);
    free_stack(stack1);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
Stack 0x55b4c76de260: 0 items starting at (nil)
Enter some lines. Press ctrl-d (EOF) to end.

</pre>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o new_stack ./new_stack.c
seq 9990 9999 | ./new_stack
</pre>
</div>

<pre class="example">
Stack 0x56180d47c260: 0 items starting at (nil)
Enter some lines. Press ctrl-d (EOF) to end.
Stack 0x56180d47c260: 1 items starting at 0x56180d47e320
Stack 0x56180d47c260: 2 items starting at 0x56180d47e320
Stack 0x56180d47c260: 3 items starting at 0x56180d47e320
Stack 0x56180d47c260: 4 items starting at 0x56180d47e4c0
Stack 0x56180d47c260: 5 items starting at 0x56180d47e4c0
Stack 0x56180d47c260: 6 items starting at 0x56180d47e5f0
Stack 0x56180d47c260: 7 items starting at 0x56180d47e5f0
Stack 0x56180d47c260: 8 items starting at 0x56180d47e730
Stack 0x56180d47c260: 9 items starting at 0x56180d47e730
Stack 0x56180d47c260: 10 items starting at 0x56180d47e880
Stack 0x56180d47c260: 9 items starting at 0x56180d47e880
9999

Stack 0x56180d47c260: 8 items starting at 0x56180d47e880
9998

Stack 0x56180d47c260: 7 items starting at 0x56180d47e880
9997

Stack 0x56180d47c260: 6 items starting at 0x56180d47e880
9996

Stack 0x56180d47c260: 5 items starting at 0x56180d47e880
9995

Stack 0x56180d47c260: 4 items starting at 0x56180d47e880
9994

Stack 0x56180d47c260: 3 items starting at 0x56180d47e880
9993

Stack 0x56180d47c260: 2 items starting at 0x56180d47e880
9992

Stack 0x56180d47c260: 1 items starting at 0x56180d47e880
9991

Stack 0x56180d47c260: 0 items starting at (nil)
9990

</pre>
</div>
</div>

<div id="outline-container-org586c3d2" class="outline-4">
<h4 id="org586c3d2"><span class="section-number-4">1.6.3</span> Test First Top Down Design</h4>
</div>
</div>

<div id="outline-container-org97a01fd" class="outline-3">
<h3 id="org97a01fd"><span class="section-number-3">1.7</span> Recursive Definitions</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-org3024025" class="outline-4">
<h4 id="org3024025"><span class="section-number-4">1.7.1</span> Mutually Recursive functions</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
How do you get functions to call each other when they need each other
to be defined?
</p>

<p>
Function prototypes!
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #228b22;">int64_t</span> <span style="color: #0000ff;">addThenDecrementThenMul</span>( <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">current</span> );
<span style="color: #228b22;">int64_t</span> <span style="color: #0000ff;">mulThenDecrementThenAdd</span>( <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">current</span> );


<span style="color: #228b22;">int64_t</span> <span style="color: #0000ff;">addThenDecrementThenMul</span>( <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">current</span> ) {
    <span style="color: #a020f0;">if</span> (current &lt;= 0) {
        <span style="color: #a020f0;">return</span> current;
    }
    <span style="color: #a020f0;">return</span> current + mulThenDecrementThenAdd( current - 1 );
}

<span style="color: #228b22;">int64_t</span> <span style="color: #0000ff;">mulThenDecrementThenAdd</span>( <span style="color: #228b22;">int64_t</span> <span style="color: #a0522d;">current</span> ) {
    <span style="color: #a020f0;">if</span> (current &lt;= 0) {
        <span style="color: #a020f0;">return</span> current;
    }
    <span style="color: #a020f0;">return</span> current * addThenDecrementThenMul( current - 1 );
}

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt;  33 ; i++ ) {
        printf(<span style="color: #8b2252;">"addThenDecrementThenMul(%4d) ==%19ld\n"</span>, i, addThenDecrementThenMul( i ));
        <span style="color: #b22222;">//</span><span style="color: #b22222;">printf("mulThenDecrementThenAdd(%4d) ==%19ld\n", i, mulThenDecrementThenAdd( i ));   </span>
    }
}
</pre>
</div>

<pre class="example">
addThenDecrementThenMul(   0) ==                  0
addThenDecrementThenMul(   1) ==                  1
addThenDecrementThenMul(   2) ==                  2
addThenDecrementThenMul(   3) ==                  5
addThenDecrementThenMul(   4) ==                 10
addThenDecrementThenMul(   5) ==                 25
addThenDecrementThenMul(   6) ==                 56
addThenDecrementThenMul(   7) ==                157
addThenDecrementThenMul(   8) ==                400
addThenDecrementThenMul(   9) ==               1265
addThenDecrementThenMul(  10) ==               3610
addThenDecrementThenMul(  11) ==              12661
addThenDecrementThenMul(  12) ==              39722
addThenDecrementThenMul(  13) ==             151945
addThenDecrementThenMul(  14) ==             516400
addThenDecrementThenMul(  15) ==            2127245
addThenDecrementThenMul(  16) ==            7746016
addThenDecrementThenMul(  17) ==           34035937
addThenDecrementThenMul(  18) ==          131682290
addThenDecrementThenMul(  19) ==          612646885
addThenDecrementThenMul(  20) ==         2501963530
addThenDecrementThenMul(  21) ==        12252937721
addThenDecrementThenMul(  22) ==        52541234152
addThenDecrementThenMul(  23) ==       269564629885
addThenDecrementThenMul(  24) ==      1208448385520
addThenDecrementThenMul(  25) ==      6469551117265
addThenDecrementThenMul(  26) ==     30211209638026
addThenDecrementThenMul(  27) ==    168208329048917
addThenDecrementThenMul(  28) ==    815702660226730
addThenDecrementThenMul(  29) ==   4709833213369705
addThenDecrementThenMul(  30) ==  23655377146575200
addThenDecrementThenMul(  31) == 141294996401091181
addThenDecrementThenMul(  32) == 733316691543831232
</pre>



<p>
If you don't use prototypes on your mutual recursive functions you will get errors like
</p>

<pre class="example">
/tmp/babel-25087Va_/C-src-25087Eoy.c: In function ‘addThenDecrementThenMul’:
/tmp/babel-25087Va_/C-src-25087Eoy.c:21:22: warning: implicit declaration of function ‘mulThenDecrementThenAdd’; did you mean ‘addThenDecrementThenMul’? [-Wimplicit-function-declaration]
     return current + mulThenDecrementThenAdd( current - 1 );
                      ^~~~~~~~~~~~~~~~~~~~~~~
                      addThenDecrementThenMul
/tmp/babel-25087Va_/C-src-25087Eoy.c: At top level:
/tmp/babel-25087Va_/C-src-25087Eoy.c:24:9: error: conflicting types for ‘mulThenDecrementThenAdd’
 int64_t mulThenDecrementThenAdd( int64_t current ) {
         ^~~~~~~~~~~~~~~~~~~~~~~
/tmp/babel-25087Va_/C-src-25087Eoy.c:21:22: note: previous implicit declaration of ‘mulThenDecrementThenAdd’ was here
     return current + mulThenDecrementThenAdd( current - 1 );
                      ^~~~~~~~~~~~~~~~~~~~~~~
/bin/bash: /tmp/babel-25087Va_/C-bin-250872xB: Permission denied
</pre>
</div>
</div>
<div id="outline-container-org6d2760b" class="outline-4">
<h4 id="org6d2760b"><span class="section-number-4">1.7.2</span> Recursive Structs</h4>
<div class="outline-text-4" id="text-1-7-2">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">enum</span> <span style="color: #228b22;">atype</span> {
   <span style="color: #a0522d;">INT</span>,
   <span style="color: #a0522d;">LONG</span>,
   <span style="color: #a0522d;">DOUBLE</span>,
   <span style="color: #a0522d;">FLOAT</span>,
};
<span style="color: #a020f0;">union</span> <span style="color: #228b22;">anything</span> {
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">anInt</span>;
<span style="color: #228b22;">long</span> <span style="color: #a0522d;">aLong</span>;
<span style="color: #228b22;">double</span> <span style="color: #a0522d;">aDouble</span>;
<span style="color: #228b22;">float</span> <span style="color: #a0522d;">aFloat</span>;
};
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span>;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> { 
    <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">atype</span> <span style="color: #a0522d;">type</span>;
    <span style="color: #a020f0;">union</span> <span style="color: #228b22;">anything</span> <span style="color: #a0522d;">value</span>;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> *<span style="color: #a0522d;">next</span>; 
};

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #0000ff;">allocLinkedList</span>( <span style="color: #a020f0;">enum</span> <span style="color: #228b22;">atype</span> <span style="color: #a0522d;">type</span>, 
                                     <span style="color: #a020f0;">union</span> <span style="color: #228b22;">anything</span> <span style="color: #a0522d;">value</span>, 
                                     <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">next</span>) {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">node</span> = malloc(<span style="color: #a020f0;">sizeof</span>(*node));
    node-&gt;type  = type;
    node-&gt;value = value;
    node-&gt;next  = next;
    <span style="color: #a020f0;">return</span> node;
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">freeLinkedList</span>( <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">list</span>) {
    <span style="color: #a020f0;">if</span> (list == <span style="color: #008b8b;">NULL</span> ){
       <span style="color: #a020f0;">return</span>;
    }
    freeLinkedList( list-&gt;next );
    free( list );
}

<span style="color: #228b22;">void</span> <span style="color: #0000ff;">freeLinkedListIterative</span>( <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">list</span>) {
    <span style="color: #a020f0;">while</span>( list != <span style="color: #008b8b;">NULL</span> ) {
        <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">freeMe</span> = list;
        list = list-&gt;next;
        free(freeMe);
    }
}


<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">union</span> <span style="color: #228b22;">anything</span> <span style="color: #a0522d;">v</span> = {.aDouble = 1.2 };
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">tail</span> = allocLinkedList( DOUBLE, v, <span style="color: #008b8b;">NULL</span>);
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">head</span> = tail;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0 ; i &lt; 10; i++) {
        v.anInt = i*2;
        head = allocLinkedList( INT, v, head );
    }
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">linkedList</span> * <span style="color: #a0522d;">iter</span> = head;
    <span style="color: #a020f0;">while</span>(iter!=<span style="color: #008b8b;">NULL</span>) {
        <span style="color: #a020f0;">if</span> (iter-&gt;type == INT) {
            printf(<span style="color: #8b2252;">"Print node value: %5d next: %p\n"</span>, iter-&gt;value.anInt, (<span style="color: #228b22;">void</span>*)iter-&gt;next);
        } <span style="color: #a020f0;">else</span> {
            printf(<span style="color: #8b2252;">"Print node type:  %5d next: %p\n"</span>, iter-&gt;type, (<span style="color: #228b22;">void</span>*)iter-&gt;next);
        }
        iter = iter-&gt;next;
        <span style="color: #b22222;">// </span><span style="color: #b22222;">iter-&gt;next ===&gt; iter</span>
    }    
    <span style="color: #b22222;">// </span><span style="color: #b22222;">freeLinkedList( head );</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">freeLinkedListIterative( head );</span>
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
Print node value:    18 next: 0x55e6b82b8380
Print node value:    16 next: 0x55e6b82b8360
Print node value:    14 next: 0x55e6b82b8340
Print node value:    12 next: 0x55e6b82b8320
Print node value:    10 next: 0x55e6b82b8300
Print node value:     8 next: 0x55e6b82b82e0
Print node value:     6 next: 0x55e6b82b82c0
Print node value:     4 next: 0x55e6b82b82a0
Print node value:     2 next: 0x55e6b82b8280
Print node value:     0 next: 0x55e6b82b8260
Print node type:      2 next: (nil)
</pre>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -Wall -pedantic -Werror -o linkedlist ./linkedlist.c
valgrind ./linkedlist 2&gt;&amp;1
<span style="color: #483d8b;">echo</span> now let<span style="color: #8b2252;">\'</span>s leak check
valgrind --leak-check=full ./linkedlist 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==19776== Memcheck, a memory error detector
==19776== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==19776== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==19776== Command: ./linkedlist
==19776== 
Print node value:    18 next: 0x522d3a0
Print node value:    16 next: 0x522d340
Print node value:    14 next: 0x522d2e0
Print node value:    12 next: 0x522d280
Print node value:    10 next: 0x522d220
Print node value:     8 next: 0x522d1c0
Print node value:     6 next: 0x522d160
Print node value:     4 next: 0x522d100
Print node value:     2 next: 0x522d0a0
Print node value:     0 next: 0x522d040
Print node type:      2 next: (nil)
==19776== 
==19776== HEAP SUMMARY:
==19776==     in use at exit: 264 bytes in 11 blocks
==19776==   total heap usage: 12 allocs, 1 frees, 4,360 bytes allocated
==19776== 
==19776== LEAK SUMMARY:
==19776==    definitely lost: 24 bytes in 1 blocks
==19776==    indirectly lost: 240 bytes in 10 blocks
==19776==      possibly lost: 0 bytes in 0 blocks
==19776==    still reachable: 0 bytes in 0 blocks
==19776==         suppressed: 0 bytes in 0 blocks
==19776== Rerun with --leak-check=full to see details of leaked memory
==19776== 
==19776== For counts of detected and suppressed errors, rerun with: -v
==19776== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
now let's leak check
==19782== Memcheck, a memory error detector
==19782== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==19782== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==19782== Command: ./linkedlist
==19782== 
Print node value:    18 next: 0x522d3a0
Print node value:    16 next: 0x522d340
Print node value:    14 next: 0x522d2e0
Print node value:    12 next: 0x522d280
Print node value:    10 next: 0x522d220
Print node value:     8 next: 0x522d1c0
Print node value:     6 next: 0x522d160
Print node value:     4 next: 0x522d100
Print node value:     2 next: 0x522d0a0
Print node value:     0 next: 0x522d040
Print node type:      2 next: (nil)
==19782== 
==19782== HEAP SUMMARY:
==19782==     in use at exit: 264 bytes in 11 blocks
==19782==   total heap usage: 12 allocs, 1 frees, 4,360 bytes allocated
==19782== 
==19782== 264 (24 direct, 240 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 3
==19782==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==19782==    by 0x1086F6: allocLinkedList (in /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week08/linkedlist)
==19782==    by 0x1087EA: main (in /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week08/linkedlist)
==19782== 
==19782== LEAK SUMMARY:
==19782==    definitely lost: 24 bytes in 1 blocks
==19782==    indirectly lost: 240 bytes in 10 blocks
==19782==      possibly lost: 0 bytes in 0 blocks
==19782==    still reachable: 0 bytes in 0 blocks
==19782==         suppressed: 0 bytes in 0 blocks
==19782== 
==19782== For counts of detected and suppressed errors, rerun with: -v
==19782== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</pre>






<p>
This is what happens when we don't free
</p>

<pre class="example">
==6238== Memcheck, a memory error detector
==6238== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==6238== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==6238== Command: ./linkedlist
==6238== 
Print node value:    18 next: 0x522d3a0
Print node value:    16 next: 0x522d340
Print node value:    14 next: 0x522d2e0
Print node value:    12 next: 0x522d280
Print node value:    10 next: 0x522d220
Print node value:     8 next: 0x522d1c0
Print node value:     6 next: 0x522d160
Print node value:     4 next: 0x522d100
Print node value:     2 next: 0x522d0a0
Print node value:     0 next: 0x522d040
Print node value:    32 next: (nil)
==6238== 
==6238== HEAP SUMMARY:
==6238==     in use at exit: 264 bytes in 11 blocks
==6238==   total heap usage: 12 allocs, 1 frees, 4,360 bytes allocated
==6238== 
==6238== LEAK SUMMARY:
==6238==    definitely lost: 24 bytes in 1 blocks
==6238==    indirectly lost: 240 bytes in 10 blocks
==6238==      possibly lost: 0 bytes in 0 blocks
==6238==    still reachable: 0 bytes in 0 blocks
==6238==         suppressed: 0 bytes in 0 blocks
==6238== Rerun with --leak-check=full to see details of leaked memory
==6238== 
==6238== For counts of detected and suppressed errors, rerun with: -v
==6238== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
now let's leak check
==6239== Memcheck, a memory error detector
==6239== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==6239== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==6239== Command: ./linkedlist
==6239== 
Print node value:    18 next: 0x522d3a0
Print node value:    16 next: 0x522d340
Print node value:    14 next: 0x522d2e0
Print node value:    12 next: 0x522d280
Print node value:    10 next: 0x522d220
Print node value:     8 next: 0x522d1c0
Print node value:     6 next: 0x522d160
Print node value:     4 next: 0x522d100
Print node value:     2 next: 0x522d0a0
Print node value:     0 next: 0x522d040
Print node value:    32 next: (nil)
==6239== 
==6239== HEAP SUMMARY:
==6239==     in use at exit: 264 bytes in 11 blocks
==6239==   total heap usage: 12 allocs, 1 frees, 4,360 bytes allocated
==6239== 
==6239== 264 (24 direct, 240 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 3
==6239==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==6239==    by 0x1086F6: allocLinkedList (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week08/linkedlist)
==6239==    by 0x1087B4: main (in /home/hindle1/projects/CMPUT201W20/2020-01/CMPUT201W20B2-public/week08/linkedlist)
==6239== 
==6239== LEAK SUMMARY:
==6239==    definitely lost: 24 bytes in 1 blocks
==6239==    indirectly lost: 240 bytes in 10 blocks
==6239==      possibly lost: 0 bytes in 0 blocks
==6239==    still reachable: 0 bytes in 0 blocks
==6239==         suppressed: 0 bytes in 0 blocks
==6239== 
==6239== For counts of detected and suppressed errors, rerun with: -v
==6239== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</pre>
</div>
</div>


<div id="outline-container-org7aef771" class="outline-4">
<h4 id="org7aef771"><span class="section-number-4">1.7.3</span> Mutually Recursive Structs</h4>
<div class="outline-text-4" id="text-1-7-3">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">x</span>;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">y</span>;
<span style="color: #b22222;">// </span><span style="color: #b22222;">field X and Y have incomplete types, NOT ALLOWED</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">try uncommenting this</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">struct z { struct x X; struct y Y; };</span>
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">x</span> { <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">y</span> *<span style="color: #a0522d;">yPtr</span>; };
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">y</span> { <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">x</span> *<span style="color: #a0522d;">xPtr</span>; };
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">z</span> { <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">x</span> <span style="color: #a0522d;">X</span>; <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">y</span> <span style="color: #a0522d;">Y</span>; };

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">x</span> <span style="color: #a0522d;">sX</span> = { .yPtr = <span style="color: #008b8b;">NULL</span> };
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">y</span> <span style="color: #a0522d;">sY</span> = { .xPtr = &amp;sX };
    sX.yPtr = &amp;sY;
    <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">z</span> <span style="color: #a0522d;">sZ</span> = { .X = sX, .Y = sY };
    printf(<span style="color: #8b2252;">"sX: %6zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(sX));
    printf(<span style="color: #8b2252;">"sY: %6zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(sY));
    printf(<span style="color: #8b2252;">"sZ: %6zu\n"</span>, <span style="color: #a020f0;">sizeof</span>(sZ));
    printf(<span style="color: #8b2252;">"sZ.X.yPtr:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)sZ.X.yPtr);
    printf(<span style="color: #8b2252;">"sZ.Y.xPtr:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)sZ.Y.xPtr);
    printf(<span style="color: #8b2252;">"&amp;sX:\t\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;sX);
    printf(<span style="color: #8b2252;">"&amp;sY:\t\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;sY);
    printf(<span style="color: #8b2252;">"&amp;sZ.X:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;(sZ.X));
    printf(<span style="color: #8b2252;">"&amp;sY.Y:\t %p\n"</span>, (<span style="color: #228b22;">void</span>*)&amp;(sZ.Y));
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<pre class="example">
sX:      8
sY:      8
sZ:     16
sZ.X.yPtr:	 0x7fff45c69d28
sZ.Y.xPtr:	 0x7fff45c69d20
&amp;sX:		 0x7fff45c69d20
&amp;sY:		 0x7fff45c69d28
&amp;sZ.X:	 0x7fff45c69d30
&amp;sY.Y:	 0x7fff45c69d38

</pre>
</div>
</div>
</div>


<div id="outline-container-org7226b43" class="outline-3">
<h3 id="org7226b43"><span class="section-number-3">1.8</span> Debugging</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-org67dfee0" class="outline-4">
<h4 id="org67dfee0"><span class="section-number-4">1.8.1</span> GDB</h4>
<div class="outline-text-4" id="text-1-8-1">
<ul class="org-ul">
<li>debuggers let us step through programs and observe variables.</li>
<li>Compile a program with -g or -ggdb3 with gcc or clang
<ul class="org-ul">
<li>this adds debugging symbols (so you can read it!)</li>
</ul></li>
<li>tell gdb to use your program
<ul class="org-ul">
<li>gdb ./a.out</li>
</ul></li>
<li>tell gdb to run your program 
<ul class="org-ul">
<li>run</li>
</ul></li>
<li>tell gbd to print a backtrace when something crashes
<ul class="org-ul">
<li>bt</li>
</ul></li>
<li>tell gdb to print a variable name
<ul class="org-ul">
<li>p string</li>
</ul></li>
<li>tell gdb to break at some point
<ul class="org-ul">
<li>b filename:function</li>
<li>b filename:line</li>
<li>b line</li>
<li>b function</li>
</ul></li>
<li>tell gdb to step into code (including into functions)
<ul class="org-ul">
<li>s</li>
</ul></li>
<li>tell gdb to eval the next line (run functions)
<ul class="org-ul">
<li>n</li>
</ul></li>
<li>keep running (continue)
<ul class="org-ul">
<li>c</li>
</ul></li>
<li>print source code (list)
<ul class="org-ul">
<li>l</li>
</ul></li>
<li>remove breakpoint
<ul class="org-ul">
<li>clear</li>
<li>clear function</li>
<li>clear line</li>
</ul></li>
<li>quit
<ul class="org-ul">
<li>q</li>
</ul></li>
<li>man gdb to get more help
<ul class="org-ul">
<li>GDB manual <a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a></li>
<li>ctrl-x a put gdb in curses semi-graphical mode</li>
<li>ddd is a graphical wrapper for gdb (probably not in your VM)
<ul class="org-ul">
<li>I like ctrl-x a better</li>
</ul></li>
</ul></li>
</ul>

<pre class="example">
hindle1@frail:~/projects/CMPUT201/CMPUT201W20B2-public/week08$ gdb ./bad_realloc 
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./bad_realloc...done.
(gdb) run
Starting program: /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week08/bad_realloc 
Stack: 0 items starting at (nil)
Enter some lines. Press ctrl-d (EOF) to end.
100

Program received signal SIGSEGV, Segmentation fault.
0x00005555555549a1 in push (stack=..., string=0x555555757670 "100\n")
    at ./bad_realloc.c:54
54	    stack.elts[stack.size-1] = string;
(gdb) p
The history is empty.
(gdb) bt
#0  0x00005555555549a1 in push (stack=..., string=0x555555757670 "100\n")
    at ./bad_realloc.c:54
#1  0x0000555555554b30 in push_input_lines (stack=...) at ./bad_realloc.c:91
#2  0x0000555555554be0 in main () at ./bad_realloc.c:111
(gdb) p stack
$1 = {size = 0, elts = 0x0}
(gdb) p stack.size
$2 = 0
(gdb) p stack.elts
$3 = (char **) 0x0
(gdb) p string
$4 = 0x555555757670 "100\n"
(gdb) l
49	    stack.size = new_size;
50	}
51	
52	void push(Stack stack, char * string) {
53	    resize(stack, stack.size + 1);
54	    stack.elts[stack.size-1] = string;
55	    show_stack(stack);
56	}
57	
58	char * pop(Stack stack) {
(gdb) 
</pre>

<p>
Here's a longer example of GDB
</p>

<pre class="example">
hindle1@frail:~/projects/CMPUT201/CMPUT201W20B2-public/week08$ gdb ./cards-aoa 
GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./cards-aoa...done.
(gdb) b isFlush
Breakpoint 1 at 0x806: file ./cards-aoa.c, line 50.
(gdb) run
Starting program: /home/hindle1/projects/CMPUT201/CMPUT201W20B2-public/week08/cards-aoa 

Breakpoint 1, isFlush (hand=0x555555757260) at ./cards-aoa.c:50
warning: Source file is more recent than executable.
50	    CardSuit suit = hand[0].suit;
(gdb) c
Continuing.

Breakpoint 1, isFlush (hand=0x555555757290) at ./cards-aoa.c:50
50	    CardSuit suit = hand[0].suit;
(gdb) c
Continuing.

Breakpoint 1, isFlush (hand=0x5555557572c0) at ./cards-aoa.c:50
50	    CardSuit suit = hand[0].suit;
(gdb) c
Continuing.

Breakpoint 1, isFlush (hand=0x5555557572f0) at ./cards-aoa.c:50
50	    CardSuit suit = hand[0].suit;
(gdb) p hand
$1 = (PlayingCard *) 0x5555557572f0
(gdb) p hand[0]
$2 = {face = QUEEN, suit = DIAMONDS}
(gdb) p hand[0].suit
$3 = DIAMONDS
(gdb) s
51	    for (int i = 1;  i &lt; HANDSIZE; i++ ) {
(gdb) s
52	        if (suit != hand[i].suit) {
(gdb) s
53	            return false;
(gdb) s
57	}
(gdb) s
main () at ./cards-aoa.c:88
88	    for (int i = 0; i &lt; HANDS; i++) {
(gdb) s
89	        if (isFlush(hands[i])) {
(gdb) s

Breakpoint 1, isFlush (hand=0x555555757320) at ./cards-aoa.c:50
50	    CardSuit suit = hand[0].suit;
(gdb) s
51	    for (int i = 1;  i &lt; HANDSIZE; i++ ) {
(gdb) s
52	        if (suit != hand[i].suit) {
(gdb) s
53	            return false;
(gdb) s
57	}
(gdb) s
main () at ./cards-aoa.c:88
88	    for (int i = 0; i &lt; HANDS; i++) {
(gdb) s
89	        if (isFlush(hands[i])) {
(gdb) s

Breakpoint 1, isFlush (hand=0x555555757350) at ./cards-aoa.c:50
50	    CardSuit suit = hand[0].suit;
(gdb) n
51	    for (int i = 1;  i &lt; HANDSIZE; i++ ) {
(gdb) n
52	        if (suit != hand[i].suit) {
(gdb) n
51	    for (int i = 1;  i &lt; HANDSIZE; i++ ) {
(gdb) n
52	        if (suit != hand[i].suit) {
(gdb) n
53	            return false;
(gdb) n
57	}
(gdb) n
main () at ./cards-aoa.c:88
88	    for (int i = 0; i &lt; HANDS; i++) {
(gdb) n
89	        if (isFlush(hands[i])) {
(gdb) n

Breakpoint 1, isFlush (hand=0x555555757380) at ./cards-aoa.c:50
50	    CardSuit suit = hand[0].suit;
(gdb) clear isFlush
Deleted breakpoint 1 
(gdb) c
Continuing.
Flush found at card 228
Suit 3
Flush found at card 291
Suit 2
Flush found at card 846
Suit 1
Flush found at card 886
Suit 2
Flush found at card 892
Suit 0
Flush found at card 1102
Suit 2
Flush found at card 1104
Suit 0
Flush found at card 1437
Suit 0
Flush found at card 1872
Suit 1
Flush found at card 2156
Suit 2
We found 3857 flushes out of 1000000 hands: 0.003857
[Inferior 1 (process 18051) exited normally]
(gdb) q
</pre>
</div>
</div>

<div id="outline-container-orgedc0ee3" class="outline-4">
<h4 id="orgedc0ee3"><span class="section-number-4">1.8.2</span> valgrind</h4>
<div class="outline-text-4" id="text-1-8-2">
<ul class="org-ul">
<li>Valgrind can debug memory issues like
<ul class="org-ul">
<li>unitialized values</li>
<li>memory leaks</li>
<li>reading/writing free'd memory</li>
<li>bad use of the stack (not great)</li>
</ul></li>

<li>valgrind ./yourprogram</li>
<li>valgrind &#x2013;tool=memcheck ./yourprogram</li>
<li>valgrind &#x2013;tool=exp-sgcheck ./yourprogram
<ul class="org-ul">
<li>for stack checks (not great)</li>
</ul></li>
<li>There's always the manual <a href="https://valgrind.org/docs/manual/manual.html">https://valgrind.org/docs/manual/manual.html</a></li>
<li>do you want a lot of output?
<ul class="org-ul">
<li>valgrind &#x2013;leak-check=full &#x2013;show-leak-kinds=all &#x2013;track-origins=yes  &#x2013;verbose ./yourprgram</li>
</ul></li>
</ul>
</div>

<ol class="org-ol">
<li><a id="org8557156"></a>Array Out of Bounds<br />
<div class="outline-text-5" id="text-1-8-2-1">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_POSIX_C_SOURCE</span> 200809L
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">/*</span>
<span style="color: #b22222;"> * This is an example of BAD CODE!</span>
<span style="color: #b22222;"> * Can you use valgrind and gdb </span>
<span style="color: #b22222;"> * to figure out what's wrong with it?</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>


<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
    printf(<span style="color: #8b2252;">"How big?\n"</span>);
    <span style="color: #a020f0;">if</span> (scanf(<span style="color: #8b2252;">"%zu"</span>, &amp;size) != 1) {
        abort();
    }

    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">array</span>[size];
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">idx</span> = 0; idx &lt; size; idx++) {
        array[idx] = 0;
    }
    
    printf(<span style="color: #8b2252;">"%d\n"</span>, array[100]);
    array[100] += 1;
    printf(<span style="color: #8b2252;">"%d\n"</span>, array[100]);
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -O0 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_oob ./array_oob.c
<span style="color: #483d8b;">echo</span> 32 | ./array_oob 
<span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">?</span>
</pre>
</div>

<pre class="example">
How big?
0
1
0

</pre>


<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -O0 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_oob ./array_oob.c
<span style="color: #483d8b;">echo</span> 6 | valgrind --leak-check=full  ./array_oob 2&gt;&amp;1
<span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">?</span>
</pre>
</div>

<pre class="example">
==21934== Memcheck, a memory error detector
==21934== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==21934== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==21934== Command: ./array_oob
==21934== 
How big?
-16775049
-16775048
==21934== 
==21934== HEAP SUMMARY:
==21934==     in use at exit: 0 bytes in 0 blocks
==21934==   total heap usage: 2 allocs, 2 frees, 8,192 bytes allocated
==21934== 
==21934== All heap blocks were freed -- no leaks are possible
==21934== 
==21934== For counts of detected and suppressed errors, rerun with: -v
==21934== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
0
</pre>

<p>
The output is dependent on your input
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 --stack-check -pedantic -Wall -Wextra -ftrapv -g3 -o array_oob ./array_oob.c || <span style="color: #483d8b;">echo</span> did not compile
<span style="color: #483d8b;">echo</span> 32 | valgrind --tool=exp-sgcheck ./array_oob 2&gt;&amp;1
<span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">?</span>
</pre>
</div>

<pre class="example">
==21996== exp-sgcheck, a stack and global array overrun detector
==21996== NOTE: This is an Experimental-Class Valgrind Tool
==21996== Copyright (C) 2003-2017, and GNU GPL'd, by OpenWorks Ltd et al.
==21996== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==21996== Command: ./array_oob
==21996== 
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
--21996-- warning: evaluate_Dwarf3_Expr: unhandled DW_OP_ 0x93
How big?
0
1
==21996== 
==21996== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
0
</pre>



<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_oob ./array_oob.c
gnome-terminal -- gdb ./array_oob
</pre>
</div>
</div>
</li>

<li><a id="orgcc3088a"></a>Array unitialized<br />
<div class="outline-text-5" id="text-1-8-2-2">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_POSIX_C_SOURCE</span> 200809L
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdlib.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>

<span style="color: #b22222;">/*</span>
<span style="color: #b22222;"> * This is an example of BAD CODE!</span>
<span style="color: #b22222;"> * Can you use valgrind and gdb </span>
<span style="color: #b22222;"> * to figure out what's wrong with it?</span>
<span style="color: #b22222;"> </span><span style="color: #b22222;">*/</span>


<span style="color: #228b22;">int</span> <span style="color: #0000ff;">main</span>() {
    <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">size</span>;
    printf(<span style="color: #8b2252;">"How big?\n"</span>);
    <span style="color: #a020f0;">if</span> (scanf(<span style="color: #8b2252;">"%zu"</span>, &amp;size) != 1) {
        abort();
    }

    <span style="color: #228b22;">int</span> <span style="color: #a0522d;">array</span>[size];
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">idx</span> = 0; idx &lt; size; idx++) {
        printf(<span style="color: #8b2252;">"%d\n"</span>, array[idx]);
    }
    <span style="color: #a020f0;">return</span> 0;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -O0 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_uninit ./array_uninit.c
<span style="color: #483d8b;">echo</span> 10 | ./array_uninit 
<span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">?</span>
</pre>
</div>

<pre class="example">
How big?
-782409112
32764
0
0
-782673888
32764
-782673984
32764
0
0
0
</pre>


<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -O0 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_uninit ./array_uninit.c
<span style="color: #483d8b;">echo</span> 5 | valgrind --leak-check=full  ./array_uninit 2&gt;&amp;1
<span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">?</span>
</pre>
</div>

<pre class="example">
==16458== Memcheck, a memory error detector
==16458== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==16458== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==16458== Command: ./array_uninit
==16458== 
==16458== Conditional jump or move depends on uninitialised value(s)
==16458==    at 0x4E988DA: vfprintf (vfprintf.c:1642)
==16458==    by 0x4EA0F25: printf (printf.c:33)
==16458==    by 0x108891: main (array_uninit.c:24)
==16458== 
==16458== Use of uninitialised value of size 8
==16458==    at 0x4E9486B: _itoa_word (_itoa.c:179)
==16458==    by 0x4E97F0D: vfprintf (vfprintf.c:1642)
==16458==    by 0x4EA0F25: printf (printf.c:33)
==16458==    by 0x108891: main (array_uninit.c:24)
==16458== 
==16458== Conditional jump or move depends on uninitialised value(s)
==16458==    at 0x4E94875: _itoa_word (_itoa.c:179)
==16458==    by 0x4E97F0D: vfprintf (vfprintf.c:1642)
==16458==    by 0x4EA0F25: printf (printf.c:33)
==16458==    by 0x108891: main (array_uninit.c:24)
==16458== 
==16458== Conditional jump or move depends on uninitialised value(s)
==16458==    at 0x4E98014: vfprintf (vfprintf.c:1642)
==16458==    by 0x4EA0F25: printf (printf.c:33)
==16458==    by 0x108891: main (array_uninit.c:24)
==16458== 
==16458== Conditional jump or move depends on uninitialised value(s)
==16458==    at 0x4E98B4C: vfprintf (vfprintf.c:1642)
==16458==    by 0x4EA0F25: printf (printf.c:33)
==16458==    by 0x108891: main (array_uninit.c:24)
==16458== 
How big?
-16776224
31
-16776320
31
0
==16458== 
==16458== HEAP SUMMARY:
==16458==     in use at exit: 0 bytes in 0 blocks
==16458==   total heap usage: 2 allocs, 2 frees, 8,192 bytes allocated
==16458== 
==16458== All heap blocks were freed -- no leaks are possible
==16458== 
==16458== For counts of detected and suppressed errors, rerun with: -v
==16458== Use --track-origins=yes to see where uninitialised values come from
==16458== ERROR SUMMARY: 57 errors from 5 contexts (suppressed: 0 from 0)
0
</pre>

<p>
Yeah valgrind did not like that. It complained about uninitiliazed values.
</p>
</div>
</li>
</ol>
</div>


<div id="outline-container-org994f210" class="outline-4">
<h4 id="org994f210"><span class="section-number-4">1.8.3</span> More bad code</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
These files are debugging examples where you should practice valgrind
and gcc.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">look a bash for loop!</span>
<span style="color: #483d8b;">echo</span> Compiling!
<span style="color: #a020f0;">for</span> file<span style="color: #a020f0;"> in</span> ./array_oob.c ./array_uninit.c ./bad_realloc.c ./bad_str.c ./double_free.c ./huge_array.c ./infinite_recursion.c ./malloc.c ./malloc_oob.c ./malloc_uninit.c ./segv.c ./simple_uninit.c ./stack.c ./stack_limit.c ./use_after_free.c 
<span style="color: #a020f0;">do</span>
gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o <span style="color: #ff00ff;">`basename -s .c $file`</span> $<span style="color: #a0522d;">file</span>
<span style="color: #a020f0;">done</span>
</pre>
</div>

<pre class="example">
Compiling!

</pre>
</div>

<ol class="org-ol">
<li><a id="orgd270618"></a>Files<br />
<div class="outline-text-6" id="text-1-8-3-0-1">
<p>
<a href="./array_oob.c">./array_oob.c</a>
<a href="./array_uninit.c">./array_uninit.c</a>
<a href="./bad_realloc.c">./bad_realloc.c</a>
<a href="./bad_str.c">./bad_str.c</a>
<a href="./double_free.c">./double_free.c</a>
<a href="./huge_array.c">./huge_array.c</a>
<a href="./infinite_recursion.c">./infinite_recursion.c</a>
<a href="./malloc.c">./malloc.c</a>
<a href="./malloc_oob.c">./malloc_oob.c</a>
<a href="./malloc_uninit.c">./malloc_uninit.c</a>
<a href="./segv.c">./segv.c</a>
<a href="./simple_uninit.c">./simple_uninit.c</a>
<a href="./stack.c">./stack.c</a>
<a href="./stack_limit.c">./stack_limit.c</a>
<a href="./use_after_free.c">./use_after_free.c</a>
</p>
</div>
</li>
</ol>

<li><a id="orgb85e186"></a>./array<sub>oob.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-1">
<p>
<a href="./array_oob.c">./array_oob.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_oob ./array_oob.c
<span style="color: #483d8b;">echo</span> 15 | valgrind ./array_oob 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==23630== Memcheck, a memory error detector
==23630== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==23630== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==23630== Command: ./array_oob
==23630== 
How big?
0
1
==23630== 
==23630== HEAP SUMMARY:
==23630==     in use at exit: 0 bytes in 0 blocks
==23630==   total heap usage: 2 allocs, 2 frees, 8,192 bytes allocated
==23630== 
==23630== All heap blocks were freed -- no leaks are possible
==23630== 
==23630== For counts of detected and suppressed errors, rerun with: -v
==23630== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_oob ./array_oob.c
gnome-terminal -- gdb ./array_oob
</pre>
</div>
</div>
</li>

<li><a id="org46a903b"></a>./array<sub>uninit.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-2">
<p>
<a href="./array_uninit.c">./array_uninit.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_uninit ./array_uninit.c
<span style="color: #483d8b;">echo</span> 7 | valgrind ./array_uninit 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==22170== Memcheck, a memory error detector
==22170== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==22170== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==22170== Command: ./array_uninit
==22170== 
==22170== Conditional jump or move depends on uninitialised value(s)
==22170==    at 0x4E988DA: vfprintf (vfprintf.c:1642)
==22170==    by 0x4EA0F25: printf (printf.c:33)
==22170==    by 0x108891: main (array_uninit.c:24)
==22170== 
==22170== Use of uninitialised value of size 8
==22170==    at 0x4E9486B: _itoa_word (_itoa.c:179)
==22170==    by 0x4E97F0D: vfprintf (vfprintf.c:1642)
==22170==    by 0x4EA0F25: printf (printf.c:33)
==22170==    by 0x108891: main (array_uninit.c:24)
==22170== 
==22170== Conditional jump or move depends on uninitialised value(s)
==22170==    at 0x4E94875: _itoa_word (_itoa.c:179)
==22170==    by 0x4E97F0D: vfprintf (vfprintf.c:1642)
==22170==    by 0x4EA0F25: printf (printf.c:33)
==22170==    by 0x108891: main (array_uninit.c:24)
==22170== 
==22170== Conditional jump or move depends on uninitialised value(s)
==22170==    at 0x4E98014: vfprintf (vfprintf.c:1642)
==22170==    by 0x4EA0F25: printf (printf.c:33)
==22170==    by 0x108891: main (array_uninit.c:24)
==22170== 
==22170== Conditional jump or move depends on uninitialised value(s)
==22170==    at 0x4E98B4C: vfprintf (vfprintf.c:1642)
==22170==    by 0x4EA0F25: printf (printf.c:33)
==22170==    by 0x108891: main (array_uninit.c:24)
==22170== 
How big?
-16776224
31
-16776320
31
0
0
1083410
==22170== 
==22170== HEAP SUMMARY:
==22170==     in use at exit: 0 bytes in 0 blocks
==22170==   total heap usage: 2 allocs, 2 frees, 8,192 bytes allocated
==22170== 
==22170== All heap blocks were freed -- no leaks are possible
==22170== 
==22170== For counts of detected and suppressed errors, rerun with: -v
==22170== Use --track-origins=yes to see where uninitialised values come from
==22170== ERROR SUMMARY: 79 errors from 5 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o array_uninit ./array_uninit.c
gnome-terminal -- gdb ./array_uninit
</pre>
</div>
</div>
</li>

<li><a id="org7ba702c"></a>./bad<sub>realloc.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-3">
<p>
<a href="./bad_realloc.c">./bad_realloc.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o bad_realloc ./bad_realloc.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./bad_realloc 2&gt;&amp;1
</pre>
</div>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o bad_realloc ./bad_realloc.c
gnome-terminal -- gdb ./bad_realloc
</pre>
</div>
</div>
</li>

<li><a id="orge559648"></a>./bad<sub>str.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-4">
<p>
<a href="./bad_str.c">./bad_str.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o bad_str ./bad_str.c
<span style="color: #483d8b;">echo</span> Coolbears | valgrind ./bad_str 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==23374== Memcheck, a memory error detector
==23374== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==23374== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==23374== Command: ./bad_str
==23374== 
==23374== Invalid write of size 1
==23374==    at 0x4EA8FDD: _IO_vfscanf (vfscanf.c:1103)
==23374==    by 0x4EB7FD7: __isoc99_scanf (isoc99_scanf.c:37)
==23374==    by 0x108773: main (bad_str.c:17)
==23374==  Address 0x522d045 is 0 bytes after a block of size 5 alloc'd
==23374==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x10874B: main (bad_str.c:15)
==23374== 
==23374== Invalid write of size 1
==23374==    at 0x4EAA942: _IO_vfscanf (vfscanf.c:1188)
==23374==    by 0x4EB7FD7: __isoc99_scanf (isoc99_scanf.c:37)
==23374==    by 0x108773: main (bad_str.c:17)
==23374==  Address 0x522d049 is 4 bytes after a block of size 5 alloc'd
==23374==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x10874B: main (bad_str.c:15)
==23374== 
==23374== Invalid read of size 1
==23374==    at 0x4C32D04: strlen (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x4E994D2: vfprintf (vfprintf.c:1643)
==23374==    by 0x4EA0F25: printf (printf.c:33)
==23374==    by 0x10878B: main (bad_str.c:18)
==23374==  Address 0x522d045 is 0 bytes after a block of size 5 alloc'd
==23374==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x10874B: main (bad_str.c:15)
==23374== 
==23374== Invalid read of size 1
==23374==    at 0x4C371F8: mempcpy (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x4EC7993: _IO_file_xsputn@@GLIBC_2.2.5 (fileops.c:1258)
==23374==    by 0x4E98FEA: vfprintf (vfprintf.c:1643)
==23374==    by 0x4EA0F25: printf (printf.c:33)
==23374==    by 0x10878B: main (bad_str.c:18)
==23374==  Address 0x522d048 is 3 bytes after a block of size 5 alloc'd
==23374==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x10874B: main (bad_str.c:15)
==23374== 
==23374== Invalid read of size 1
==23374==    at 0x4C3720A: mempcpy (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x4EC7993: _IO_file_xsputn@@GLIBC_2.2.5 (fileops.c:1258)
==23374==    by 0x4E98FEA: vfprintf (vfprintf.c:1643)
==23374==    by 0x4EA0F25: printf (printf.c:33)
==23374==    by 0x10878B: main (bad_str.c:18)
==23374==  Address 0x522d046 is 1 bytes after a block of size 5 alloc'd
==23374==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23374==    by 0x10874B: main (bad_str.c:15)
==23374== 
Enter a message:
You entered: Coolbears
==23374== 
==23374== HEAP SUMMARY:
==23374==     in use at exit: 5 bytes in 1 blocks
==23374==   total heap usage: 3 allocs, 2 frees, 8,197 bytes allocated
==23374== 
==23374== LEAK SUMMARY:
==23374==    definitely lost: 5 bytes in 1 blocks
==23374==    indirectly lost: 0 bytes in 0 blocks
==23374==      possibly lost: 0 bytes in 0 blocks
==23374==    still reachable: 0 bytes in 0 blocks
==23374==         suppressed: 0 bytes in 0 blocks
==23374== Rerun with --leak-check=full to see details of leaked memory
==23374== 
==23374== For counts of detected and suppressed errors, rerun with: -v
==23374== ERROR SUMMARY: 14 errors from 5 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o bad_str ./bad_str.c
gnome-terminal -- gdb ./bad_str
</pre>
</div>
</div>
</li>

<li><a id="orgf9c9a00"></a>./double<sub>free.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-5">
<p>
<a href="./double_free.c">./double_free.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o double_free ./double_free.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./double_free 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==23937== Memcheck, a memory error detector
==23937== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==23937== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==23937== Command: ./double_free
==23937== 
==23937== Invalid free() / delete / delete[] / realloc()
==23937==    at 0x4C30D3B: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23937==    by 0x108904: main (double_free.c:27)
==23937==  Address 0x522f0c0 is 0 bytes inside a block of size 132 free'd
==23937==    at 0x4C30D3B: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23937==    by 0x1088F8: main (double_free.c:26)
==23937==  Block was alloc'd at
==23937==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==23937==    by 0x10888E: main (double_free.c:21)
==23937== 
How big?
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
==23937== 
==23937== HEAP SUMMARY:
==23937==     in use at exit: 0 bytes in 0 blocks
==23937==   total heap usage: 3 allocs, 4 frees, 8,324 bytes allocated
==23937== 
==23937== All heap blocks were freed -- no leaks are possible
==23937== 
==23937== For counts of detected and suppressed errors, rerun with: -v
==23937== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o double_free ./double_free.c
gnome-terminal -- gdb ./double_free
</pre>
</div>
</div>
</li>

<li><a id="org9005fc8"></a>./huge<sub>array.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-6">
<p>
<a href="./huge_array.c">./huge_array.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o huge_array ./huge_array.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./huge_array 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==27323== Memcheck, a memory error detector
==27323== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==27323== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==27323== Command: ./huge_array
==27323== 
==27323== Warning: client switching stacks?  SP change: 0x1fff0003e0 --&gt; 0x1ffe8003d0
==27323==          to suppress, use: --max-stackframe=8388624 or greater
==27323== Invalid write of size 8
==27323==    at 0x108728: main (huge_array.c:14)
==27323==  Address 0x1ffe8003c8 is on thread 1's stack
==27323==  in frame #0, created by main (huge_array.c:13)
==27323== 
==27323== Invalid write of size 8
==27323==    at 0x4C36657: memset (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==27323==    by 0x10872C: main (huge_array.c:14)
==27323==  Address 0x1ffe8003d0 is on thread 1's stack
==27323==  in frame #1, created by main (huge_array.c:13)
==27323== 
==27323== Invalid write of size 8
==27323==    at 0x4C3665A: memset (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==27323==    by 0x10872C: main (huge_array.c:14)
==27323==  Address 0x1ffe8003d8 is on thread 1's stack
==27323==  in frame #1, created by main (huge_array.c:13)
==27323== 
==27323== Invalid write of size 8
==27323==    at 0x4C3665E: memset (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==27323==    by 0x10872C: main (huge_array.c:14)
==27323==  Address 0x1ffe8003e0 is on thread 1's stack
==27323==  in frame #1, created by main (huge_array.c:13)
==27323== 
==27323== Invalid write of size 8
==27323==    at 0x4C36662: memset (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==27323==    by 0x10872C: main (huge_array.c:14)
==27323==  Address 0x1ffe8003e8 is on thread 1's stack
==27323==  in frame #1, created by main (huge_array.c:13)
==27323== 
==27323== Invalid read of size 8
==27323==    at 0x4C366D5: memset (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==27323==    by 0x10872C: main (huge_array.c:14)
==27323==  Address 0x1ffe8003c8 is on thread 1's stack
==27323==  in frame #0, created by memset (???:)
==27323== 
==27323== Invalid read of size 4
==27323==    at 0x10872D: main (huge_array.c:15)
==27323==  Address 0x1ffe8003d0 is on thread 1's stack
==27323==  in frame #0, created by main (huge_array.c:13)
==27323== 
==27323== Warning: client switching stacks?  SP change: 0x1ffe8003d0 --&gt; 0x1fff0003e0
==27323==          to suppress, use: --max-stackframe=8388624 or greater
0
==27323== 
==27323== HEAP SUMMARY:
==27323==     in use at exit: 0 bytes in 0 blocks
==27323==   total heap usage: 1 allocs, 1 frees, 4,096 bytes allocated
==27323== 
==27323== All heap blocks were freed -- no leaks are possible
==27323== 
==27323== For counts of detected and suppressed errors, rerun with: -v
==27323== ERROR SUMMARY: 1048565 errors from 7 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o huge_array ./huge_array.c
gnome-terminal -- gdb ./huge_array
</pre>
</div>
</div>
</li>

<li><a id="orgd7f395e"></a>./malloc<sub>oob.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-7">
<p>
<a href="./malloc_oob.c">./malloc_oob.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o malloc_oob ./malloc_oob.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./malloc_oob 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==27315== Memcheck, a memory error detector
==27315== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==27315== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==27315== Command: ./malloc_oob
==27315== 
==27315== Invalid read of size 4
==27315==    at 0x1088CF: main (malloc_oob.c:26)
==27315==  Address 0x522f250 is 192 bytes inside an unallocated block of size 4,185,680 in arena "client"
==27315== 
How big?
0
==27315== 
==27315== HEAP SUMMARY:
==27315==     in use at exit: 0 bytes in 0 blocks
==27315==   total heap usage: 3 allocs, 3 frees, 8,324 bytes allocated
==27315== 
==27315== All heap blocks were freed -- no leaks are possible
==27315== 
==27315== For counts of detected and suppressed errors, rerun with: -v
==27315== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o malloc_oob ./malloc_oob.c
gnome-terminal -- gdb ./malloc_oob
</pre>
</div>
</div>
</li>

<li><a id="org4ddf6e8"></a>./malloc<sub>uninit.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-8">
<p>
<a href="./malloc_uninit.c">./malloc_uninit.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o malloc_uninit ./malloc_uninit.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./malloc_uninit 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==27303== Memcheck, a memory error detector
==27303== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==27303== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==27303== Command: ./malloc_uninit
==27303== 
==27303== Conditional jump or move depends on uninitialised value(s)
==27303==    at 0x4E988DA: vfprintf (vfprintf.c:1642)
==27303==    by 0x4EA0F25: printf (printf.c:33)
==27303==    by 0x108884: main (malloc_uninit.c:25)
==27303== 
==27303== Use of uninitialised value of size 8
==27303==    at 0x4E9486B: _itoa_word (_itoa.c:179)
==27303==    by 0x4E97F0D: vfprintf (vfprintf.c:1642)
==27303==    by 0x4EA0F25: printf (printf.c:33)
==27303==    by 0x108884: main (malloc_uninit.c:25)
==27303== 
==27303== Conditional jump or move depends on uninitialised value(s)
==27303==    at 0x4E94875: _itoa_word (_itoa.c:179)
==27303==    by 0x4E97F0D: vfprintf (vfprintf.c:1642)
==27303==    by 0x4EA0F25: printf (printf.c:33)
==27303==    by 0x108884: main (malloc_uninit.c:25)
==27303== 
==27303== Conditional jump or move depends on uninitialised value(s)
==27303==    at 0x4E98014: vfprintf (vfprintf.c:1642)
==27303==    by 0x4EA0F25: printf (printf.c:33)
==27303==    by 0x108884: main (malloc_uninit.c:25)
==27303== 
==27303== Conditional jump or move depends on uninitialised value(s)
==27303==    at 0x4E98B4C: vfprintf (vfprintf.c:1642)
==27303==    by 0x4EA0F25: printf (printf.c:33)
==27303==    by 0x108884: main (malloc_uninit.c:25)
==27303== 
How big?
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
==27303== 
==27303== HEAP SUMMARY:
==27303==     in use at exit: 132 bytes in 1 blocks
==27303==   total heap usage: 3 allocs, 2 frees, 8,324 bytes allocated
==27303== 
==27303== LEAK SUMMARY:
==27303==    definitely lost: 132 bytes in 1 blocks
==27303==    indirectly lost: 0 bytes in 0 blocks
==27303==      possibly lost: 0 bytes in 0 blocks
==27303==    still reachable: 0 bytes in 0 blocks
==27303==         suppressed: 0 bytes in 0 blocks
==27303== Rerun with --leak-check=full to see details of leaked memory
==27303== 
==27303== For counts of detected and suppressed errors, rerun with: -v
==27303== Use --track-origins=yes to see where uninitialised values come from
==27303== ERROR SUMMARY: 165 errors from 5 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o malloc_uninit ./malloc_uninit.c
gnome-terminal -- gdb ./malloc_uninit
</pre>
</div>
</div>
</li>

<li><a id="org125b2ad"></a>./segv.c<br />
<div class="outline-text-5" id="text-1-8-3-9">
<p>
<a href="./segv.c">./segv.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o segv ./segv.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./segv 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==27291== Memcheck, a memory error detector
==27291== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==27291== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==27291== Command: ./segv
==27291== 
==27291== Invalid read of size 4
==27291==    at 0x1088CF: main (segv.c:26)
==27291==  Address 0x55ff9c0 is 3,999,792 bytes inside an unallocated block of size 4,185,680 in arena "client"
==27291== 
How big?
0
==27291== 
==27291== HEAP SUMMARY:
==27291==     in use at exit: 0 bytes in 0 blocks
==27291==   total heap usage: 3 allocs, 3 frees, 8,324 bytes allocated
==27291== 
==27291== All heap blocks were freed -- no leaks are possible
==27291== 
==27291== For counts of detected and suppressed errors, rerun with: -v
==27291== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o segv ./segv.c
gnome-terminal -- gdb ./segv
</pre>
</div>
</div>
</li>

<li><a id="orgbf1c8c8"></a>./simple<sub>uninit.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-10">
<p>
<a href="./simple_uninit.c">./simple_uninit.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o simple_uninit ./simple_uninit.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./simple_uninit 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==27279== Memcheck, a memory error detector
==27279== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==27279== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==27279== Command: ./simple_uninit
==27279== 
Enter an int:
33
==27279== 
==27279== HEAP SUMMARY:
==27279==     in use at exit: 0 bytes in 0 blocks
==27279==   total heap usage: 2 allocs, 2 frees, 8,192 bytes allocated
==27279== 
==27279== All heap blocks were freed -- no leaks are possible
==27279== 
==27279== For counts of detected and suppressed errors, rerun with: -v
==27279== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o simple_uninit ./simple_uninit.c
gnome-terminal -- gdb ./simple_uninit
</pre>
</div>
</div>
</li>

<li><a id="org40eee0d"></a>./stack.c<br />
<div class="outline-text-5" id="text-1-8-3-11">
<p>
<a href="./stack.c">./stack.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o stack ./stack.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./stack 2&gt;&amp;1
</pre>
</div>

<pre class="example">
==27253== Memcheck, a memory error detector
==27253== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==27253== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==27253== Command: ./stack
==27253== 
Stack 0x522d040: 0 items starting at (nil)
Enter some lines. Press ctrl-d (EOF) to end.
Stack 0x522d040: 1 items starting at 0x522f1d0
Stack 0x522d040: 0 items starting at (nil)
33
==27253== 
==27253== HEAP SUMMARY:
==27253==     in use at exit: 0 bytes in 1 blocks
==27253==   total heap usage: 7 allocs, 6 frees, 8,456 bytes allocated
==27253== 
==27253== LEAK SUMMARY:
==27253==    definitely lost: 0 bytes in 1 blocks
==27253==    indirectly lost: 0 bytes in 0 blocks
==27253==      possibly lost: 0 bytes in 0 blocks
==27253==    still reachable: 0 bytes in 0 blocks
==27253==         suppressed: 0 bytes in 0 blocks
==27253== Rerun with --leak-check=full to see details of leaked memory
==27253== 
==27253== For counts of detected and suppressed errors, rerun with: -v
==27253== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o stack ./stack.c
gnome-terminal -- gdb ./stack
</pre>
</div>
</div>
</li>

<li><a id="org00b0836"></a>./stack<sub>limit.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-12">
<p>
<a href="./stack_limit.c">./stack_limit.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o stack_limit ./stack_limit.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./stack_limit 2&gt;&amp;1
</pre>
</div>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o stack_limit ./stack_limit.c
gnome-terminal -- gdb ./stack_limit
</pre>
</div>
</div>
</li>

<li><a id="org7c54c1b"></a>./use<sub>after</sub><sub>free.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-13">
<p>
<a href="./use_after_free.c">./use_after_free.c</a>
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o use_after_free ./use_after_free.c
<span style="color: #483d8b;">echo</span> 33 | valgrind ./use_after_free 2&gt;&amp;1
</pre>
</div>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o use_after_free ./use_after_free.c
gnome-terminal -- gdb ./use_after_free
</pre>
</div>
</div>
</li>



<li><a id="org0be1bf8"></a>./infinite<sub>recursion.c</sub><br />
<div class="outline-text-5" id="text-1-8-3-14">
<p>
<a href="./infinite_recursion.c">./infinite_recursion.c</a>
</p>

<p>
Run GDB
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o infinite_recursion ./infinite_recursion.c
gnome-terminal -- gdb ./infinite_recursion
</pre>
</div>

<p>
Run valgrind
</p>
<div class="org-src-container">
<pre class="src src-sh">gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o infinite_recursion ./infinite_recursion.c
<span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">"valgrind ./infinite_recursion ; read"</span> &gt; infinite_recursion.sh
gnome-terminal -- bash infinite_recursion.sh 
</pre>
</div>

<p>
Valgrind results
</p>

<pre class="example">
depth: 261795
==6818== Stack overflow in thread #1: can't grow stack to 0x1ffe801000
depth: 261796
==6818== Stack overflow in thread #1: can't grow stack to 0x1ffe801000
depth: 261797
==6818== Stack overflow in thread #1: can't grow stack to 0x1ffe801000
depth: 261798
==6818== Stack overflow in thread #1: can't grow stack to 0x1ffe801000
depth: 261799
==6818== Stack overflow in thread #1: can't grow stack to 0x1ffe801000
</pre>
</div>


<ol class="org-ol">
<li><a id="orge31235d"></a>Generator (ignore)<br />
<div class="outline-text-6" id="text-1-8-3-14-1">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #b22222;"># </span><span style="color: #b22222;">look a bash for loop!</span>
<span style="color: #a020f0;">for</span> file<span style="color: #a020f0;"> in</span> ./array_oob.c ./array_uninit.c ./bad_realloc.c ./bad_str.c ./double_free.c ./huge_array.c ./malloc_oob.c ./malloc_uninit.c ./segv.c ./simple_uninit.c ./stack.c ./stack_limit.c ./use_after_free.c 
<span style="color: #b22222;">#</span><span style="color: #b22222;">for file in ./array_oob.c ./array_uninit.c ./bad_realloc.c </span>
<span style="color: #a020f0;">do</span>
<span style="color: #a0522d;">exe</span>=<span style="color: #ff00ff;">`basename -s .c $file`</span>
<span style="color: #483d8b;">echo</span>
<span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">\*\*\*\*</span> $<span style="color: #a0522d;">file</span>
<span style="color: #483d8b;">echo</span> file:$<span style="color: #a0522d;">file</span>
<span style="color: #483d8b;">echo</span> 
<span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">\#</span>+BEGIN_SRC sh 
<span style="color: #483d8b;">echo</span> gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o $<span style="color: #a0522d;">exe</span> $<span style="color: #a0522d;">file</span>
<span style="color: #483d8b;">echo</span> echo 33 <span style="color: #8b2252;">\|</span> valgrind ./$<span style="color: #a0522d;">exe</span> 2<span style="color: #8b2252;">\&gt;\&amp;</span>1
<span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">\#</span>+END_SRC
<span style="color: #483d8b;">echo</span> 
<span style="color: #483d8b;">echo</span> Run GDB
<span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">\#</span>+BEGIN_SRC sh 
<span style="color: #483d8b;">echo</span> gcc -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 -o $<span style="color: #a0522d;">exe</span> $<span style="color: #a0522d;">file</span>
<span style="color: #483d8b;">echo</span> gnome-terminal -- gdb ./$<span style="color: #a0522d;">exe</span>
<span style="color: #483d8b;">echo</span> <span style="color: #8b2252;">\#</span>+END_SRC
<span style="color: #a020f0;">done</span>
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abram Hindle</p>
<p class="date">Created: 2020-03-10 Tue 10:14</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
